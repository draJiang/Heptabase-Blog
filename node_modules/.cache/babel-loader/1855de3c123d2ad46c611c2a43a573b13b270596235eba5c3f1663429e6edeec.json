{"ast":null,"code":"/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar Negotiator = require('negotiator');\nvar mime = require('mime-types');\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Accepts;\n\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts(req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req);\n  }\n  this.headers = req.headers;\n  this.negotiator = new Negotiator(req);\n}\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\nAccepts.prototype.type = Accepts.prototype.types = function (types_) {\n  var types = types_;\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length);\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i];\n    }\n  }\n\n  // no types, return all requested types\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes();\n  }\n\n  // no accept header, return first given type\n  if (!this.headers.accept) {\n    return types[0];\n  }\n  var mimes = types.map(extToMime);\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));\n  var first = accepts[0];\n  return first ? types[mimes.indexOf(first)] : false;\n};\n\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_;\n\n  // support flattened arguments\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length);\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i];\n    }\n  }\n\n  // no encodings, return all requested encodings\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings();\n  }\n  return this.negotiator.encodings(encodings)[0] || false;\n};\n\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_;\n\n  // support flattened arguments\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length);\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i];\n    }\n  }\n\n  // no charsets, return all requested charsets\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets();\n  }\n  return this.negotiator.charsets(charsets)[0] || false;\n};\n\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\nAccepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {\n  var languages = languages_;\n\n  // support flattened arguments\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length);\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i];\n    }\n  }\n\n  // no languages, return all requested languages\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages();\n  }\n  return this.negotiator.languages(languages)[0] || false;\n};\n\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction extToMime(type) {\n  return type.indexOf('/') === -1 ? mime.lookup(type) : type;\n}\n\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction validMime(type) {\n  return typeof type === 'string';\n}","map":{"version":3,"names":["Negotiator","require","mime","module","exports","Accepts","req","headers","negotiator","prototype","type","types","types_","Array","isArray","arguments","length","i","mediaTypes","accept","mimes","map","extToMime","accepts","filter","validMime","first","indexOf","encoding","encodings","encodings_","charset","charsets","charsets_","lang","langs","language","languages","languages_","lookup"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/accepts/index.js"],"sourcesContent":["/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Negotiator = require('negotiator')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Accepts\n\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts (req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req)\n  }\n\n  this.headers = req.headers\n  this.negotiator = new Negotiator(req)\n}\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\nAccepts.prototype.type =\nAccepts.prototype.types = function (types_) {\n  var types = types_\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i]\n    }\n  }\n\n  // no types, return all requested types\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes()\n  }\n\n  // no accept header, return first given type\n  if (!this.headers.accept) {\n    return types[0]\n  }\n\n  var mimes = types.map(extToMime)\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))\n  var first = accepts[0]\n\n  return first\n    ? types[mimes.indexOf(first)]\n    : false\n}\n\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.encoding =\nAccepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_\n\n  // support flattened arguments\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length)\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i]\n    }\n  }\n\n  // no encodings, return all requested encodings\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings()\n  }\n\n  return this.negotiator.encodings(encodings)[0] || false\n}\n\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.charset =\nAccepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_\n\n  // support flattened arguments\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length)\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i]\n    }\n  }\n\n  // no charsets, return all requested charsets\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets()\n  }\n\n  return this.negotiator.charsets(charsets)[0] || false\n}\n\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\nAccepts.prototype.lang =\nAccepts.prototype.langs =\nAccepts.prototype.language =\nAccepts.prototype.languages = function (languages_) {\n  var languages = languages_\n\n  // support flattened arguments\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length)\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i]\n    }\n  }\n\n  // no languages, return all requested languages\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages()\n  }\n\n  return this.negotiator.languages(languages)[0] || false\n}\n\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction extToMime (type) {\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction validMime (type) {\n  return typeof type === 'string'\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}