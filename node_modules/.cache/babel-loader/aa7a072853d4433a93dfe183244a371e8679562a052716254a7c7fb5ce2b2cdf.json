{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { htmlBlockNames, htmlRawNames } from 'micromark-util-html-tag-name';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { blankLine } from './blank-line.js';\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n};\n\n/** @type {Construct} */\nconst nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n};\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length;\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === types.htmlFlow) {\n      break;\n    }\n  }\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start;\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start;\n    // Remove the line prefix.\n    events.splice(index - 2, 2);\n  }\n  return events;\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this;\n  /** @type {number} */\n  let kind;\n  /** @type {boolean} */\n  let startTag;\n  /** @type {string} */\n  let buffer;\n  /** @type {number} */\n  let index;\n  /** @type {Code} */\n  let marker;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlFlow);\n    effects.enter(types.htmlFlowData);\n    effects.consume(code);\n    return open;\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationStart;\n    }\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      kind = constants.htmlInstruction;\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      startTag = true;\n      return tagName;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function declarationStart(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      kind = constants.htmlComment;\n      return commentOpenInside;\n    }\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      kind = constants.htmlCdata;\n      buffer = constants.cdataOpeningString;\n      index = 0;\n      return cdataOpenInside;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      kind = constants.htmlDeclaration;\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? self.interrupt ? ok : continuation : cdataOpenInside;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function tagName(code) {\n    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      if (code !== codes.slash && startTag && htmlRawNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlRaw;\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlBasic;\n        if (code === codes.slash) {\n          effects.consume(code);\n          return basicSelfClosing;\n        }\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n      kind = constants.htmlComplete;\n      // Do not support complete HTML when interrupting\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);\n    }\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuation;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n    return completeEnd(code);\n  }\n\n  /** @type {State} */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return completeEnd;\n    }\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n    return completeEnd(code);\n  }\n\n  /** @type {State} */\n  function completeAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n    return completeAttributeNameAfter(code);\n  }\n\n  /** @type {State} */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n    return completeAttributeNameBefore(code);\n  }\n\n  /** @type {State} */\n  function completeAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return completeAttributeValueQuoted;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n    marker = null;\n    return completeAttributeValueUnquoted(code);\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuoted(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n    if (code === marker) {\n      effects.consume(code);\n      return completeAttributeValueQuotedAfter;\n    }\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n\n  /** @type {State} */\n  function completeAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {\n      return completeAttributeNameAfter(code);\n    }\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {\n      return completeAttributeNameBefore(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return completeAfter;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n    return code === codes.eof || markdownLineEnding(code) ? continuation(code) : nok(code);\n  }\n\n  /** @type {State} */\n  function continuation(code) {\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n    if (code === codes.lessThan && kind === constants.htmlRaw) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n    if (code === codes.greaterThan && kind === constants.htmlDeclaration) {\n      effects.consume(code);\n      return continuationClose;\n    }\n    if (code === codes.questionMark && kind === constants.htmlInstruction) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    if (code === codes.rightSquareBracket && kind === constants.htmlCdata) {\n      effects.consume(code);\n      return continuationCharacterDataInside;\n    }\n    if (markdownLineEnding(code) && (kind === constants.htmlBasic || kind === constants.htmlComplete)) {\n      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);\n    }\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code);\n    }\n    effects.consume(code);\n    return continuation;\n  }\n\n  /** @type {State} */\n  function continuationAtLineEnding(code) {\n    effects.exit(types.htmlFlowData);\n    return htmlContinueStart(code);\n  }\n\n  /** @type {State} */\n  function htmlContinueStart(code) {\n    if (code === codes.eof) {\n      return done(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt({\n        tokenize: htmlLineEnd,\n        partial: true\n      }, htmlContinueStart, done)(code);\n    }\n    effects.enter(types.htmlFlowData);\n    return continuation(code);\n  }\n\n  /** @type {Tokenizer} */\n  function htmlLineEnd(effects, ok, nok) {\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return lineStart;\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n\n  /** @type {State} */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n\n  /** @type {State} */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      buffer = '';\n      return continuationRawEndTag;\n    }\n    return continuation(code);\n  }\n\n  /** @type {State} */\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan && htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code);\n      return continuationClose;\n    }\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n    return continuation(code);\n  }\n\n  /** @type {State} */\n  function continuationCharacterDataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n\n  /** @type {State} */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    // More dashes.\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n\n  /** @type {State} */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return done(code);\n    }\n    effects.consume(code);\n    return continuationClose;\n  }\n\n  /** @type {State} */\n  function done(code) {\n    effects.exit(types.htmlFlow);\n    return ok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending');\n    effects.exit(types.htmlFlowData);\n    effects.enter(types.lineEndingBlank);\n    effects.consume(code);\n    effects.exit(types.lineEndingBlank);\n    return effects.attempt(blankLine, ok, nok);\n  }\n}","map":{"version":3,"names":["ok","assert","asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","htmlBlockNames","htmlRawNames","codes","constants","types","blankLine","htmlFlow","name","tokenize","tokenizeHtmlFlow","resolveTo","resolveToHtmlFlow","concrete","nextBlankConstruct","tokenizeNextBlank","partial","events","index","length","type","linePrefix","start","splice","effects","nok","self","kind","startTag","buffer","marker","code","lessThan","enter","htmlFlowData","consume","open","exclamationMark","declarationStart","slash","tagCloseStart","questionMark","htmlInstruction","interrupt","continuationDeclarationInside","String","fromCharCode","tagName","dash","htmlComment","commentOpenInside","leftSquareBracket","htmlCdata","cdataOpeningString","cdataOpenInside","htmlDeclaration","charCodeAt","continuation","eof","greaterThan","includes","toLowerCase","htmlRaw","htmlBasic","basicSelfClosing","htmlComplete","parser","lazy","now","line","completeAttributeNameBefore","completeClosingTagAfter","completeEnd","colon","underscore","completeAttributeName","dot","completeAttributeNameAfter","equalsTo","completeAttributeValueBefore","graveAccent","quotationMark","apostrophe","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","rightSquareBracket","continuationCharacterDataInside","check","continuationAtLineEnding","exit","htmlContinueStart","done","attempt","htmlLineEnd","lineEnding","lineStart","continuationRawEndTag","htmlRawSizeMax","lineEndingBlank"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/html-flow.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nextBlankConstruct = {tokenize: tokenizeNextBlank, partial: true}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === types.htmlFlow\n    ) {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let kind\n  /** @type {boolean} */\n  let startTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let marker\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlFlow)\n    effects.enter(types.htmlFlowData)\n    effects.consume(code)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      kind = constants.htmlInstruction\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function declarationStart(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      kind = constants.htmlComment\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      kind = constants.htmlCdata\n      buffer = constants.cdataOpeningString\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = constants.htmlDeclaration\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagName(code) {\n    if (\n      code === codes.eof ||\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== codes.slash &&\n        startTag &&\n        htmlRawNames.includes(buffer.toLowerCase())\n      ) {\n        kind = constants.htmlRaw\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlBasic\n\n        if (code === codes.slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = constants.htmlComplete\n      // Do not support complete HTML when interrupting\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeName(code) {\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = null\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuoted(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /** @type {State} */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownSpace(code)\n    ) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === codes.eof || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n\n  /** @type {State} */\n  function continuation(code) {\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === codes.lessThan && kind === constants.htmlRaw) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === codes.greaterThan && kind === constants.htmlDeclaration) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === codes.questionMark && kind === constants.htmlInstruction) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === codes.rightSquareBracket && kind === constants.htmlCdata) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (\n      markdownLineEnding(code) &&\n      (kind === constants.htmlBasic || kind === constants.htmlComplete)\n    ) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  /** @type {State} */\n  function continuationAtLineEnding(code) {\n    effects.exit(types.htmlFlowData)\n    return htmlContinueStart(code)\n  }\n\n  /** @type {State} */\n  function htmlContinueStart(code) {\n    if (code === codes.eof) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        {tokenize: htmlLineEnd, partial: true},\n        htmlContinueStart,\n        done\n      )(code)\n    }\n\n    effects.enter(types.htmlFlowData)\n    return continuation(code)\n  }\n\n  /** @type {Tokenizer} */\n  function htmlLineEnd(effects, ok, nok) {\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return lineStart\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n\n  /** @type {State} */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationRawEndTag(code) {\n    if (\n      code === codes.greaterThan &&\n      htmlRawNames.includes(buffer.toLowerCase())\n    ) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationCharacterDataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /** @type {State} */\n  function done(code) {\n    effects.exit(types.htmlFlow)\n    return ok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.exit(types.htmlFlowData)\n    effects.enter(types.lineEndingBlank)\n    effects.consume(code)\n    effects.exit(types.lineEndingBlank)\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}