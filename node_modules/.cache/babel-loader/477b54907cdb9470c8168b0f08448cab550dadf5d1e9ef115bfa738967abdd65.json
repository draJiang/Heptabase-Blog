{"ast":null,"code":"'use strict';\n\nconst unicode = require('../common/unicode');\nconst ERR = require('../common/error-codes');\n\n//Aliases\nconst $ = unicode.CODE_POINTS;\n\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n  constructor() {\n    this.html = null;\n    this.pos = -1;\n    this.lastGapPos = -1;\n    this.lastCharPos = -1;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n  }\n  _err() {\n    // NOTE: err reporting is noop by default. Enabled by mixin.\n  }\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.lastCharPos) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n      if (unicode.isSurrogatePair(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++;\n\n        //NOTE: add gap that should be avoided during retreat\n        this._addGap();\n        return unicode.getSurrogatePairCodePoint(cp, nextCp);\n      }\n    }\n\n    //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return $.EOF;\n    }\n\n    //NOTE: isolated surrogate\n    this._err(ERR.surrogateInInputStream);\n    return cp;\n  }\n  dropParsedChunk() {\n    if (this.pos > this.bufferWaterline) {\n      this.lastCharPos -= this.pos;\n      this.html = this.html.substring(this.pos);\n      this.pos = 0;\n      this.lastGapPos = -1;\n      this.gapStack = [];\n    }\n  }\n  write(chunk, isLastChunk) {\n    if (this.html) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n    this.lastCharPos = this.html.length - 1;\n    this.endOfChunkHit = false;\n  }\n  advance() {\n    this.pos++;\n    if (this.pos > this.lastCharPos) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return $.EOF;\n    }\n    let cp = this.html.charCodeAt(this.pos);\n\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (this.skipNextNewLine && cp === $.LINE_FEED) {\n      this.skipNextNewLine = false;\n      this._addGap();\n      return this.advance();\n    }\n\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === $.CARRIAGE_RETURN) {\n      this.skipNextNewLine = true;\n      return $.LINE_FEED;\n    }\n    this.skipNextNewLine = false;\n    if (unicode.isSurrogate(cp)) {\n      cp = this._processSurrogate(cp);\n    }\n\n    //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n    const isCommonValidRange = cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 0xfdd0;\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n    return cp;\n  }\n  _checkForProblematicCharacters(cp) {\n    if (unicode.isControlCodePoint(cp)) {\n      this._err(ERR.controlCharacterInInputStream);\n    } else if (unicode.isUndefinedCodePoint(cp)) {\n      this._err(ERR.noncharacterInInputStream);\n    }\n  }\n  retreat() {\n    if (this.pos === this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n    this.pos--;\n  }\n}\nmodule.exports = Preprocessor;","map":{"version":3,"names":["unicode","require","ERR","$","CODE_POINTS","DEFAULT_BUFFER_WATERLINE","Preprocessor","constructor","html","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","_err","_addGap","push","_processSurrogate","cp","nextCp","charCodeAt","isSurrogatePair","getSurrogatePairCodePoint","EOF","surrogateInInputStream","dropParsedChunk","substring","write","chunk","isLastChunk","length","insertHtmlAtCurrentPos","advance","LINE_FEED","CARRIAGE_RETURN","isSurrogate","isCommonValidRange","_checkForProblematicCharacters","isControlCodePoint","controlCharacterInInputStream","isUndefinedCodePoint","noncharacterInInputStream","retreat","pop","module","exports"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/parse5/lib/tokenizer/preprocessor.js"],"sourcesContent":["'use strict';\n\nconst unicode = require('../common/unicode');\nconst ERR = require('../common/error-codes');\n\n//Aliases\nconst $ = unicode.CODE_POINTS;\n\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n    constructor() {\n        this.html = null;\n\n        this.pos = -1;\n        this.lastGapPos = -1;\n        this.lastCharPos = -1;\n\n        this.gapStack = [];\n\n        this.skipNextNewLine = false;\n\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    }\n\n    _err() {\n        // NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.lastCharPos) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n\n            if (unicode.isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n\n                //NOTE: add gap that should be avoided during retreat\n                this._addGap();\n\n                return unicode.getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n\n        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n\n        return cp;\n    }\n\n    dropParsedChunk() {\n        if (this.pos > this.bufferWaterline) {\n            this.lastCharPos -= this.pos;\n            this.html = this.html.substring(this.pos);\n            this.pos = 0;\n            this.lastGapPos = -1;\n            this.gapStack = [];\n        }\n    }\n\n    write(chunk, isLastChunk) {\n        if (this.html) {\n            this.html += chunk;\n        } else {\n            this.html = chunk;\n        }\n\n        this.lastCharPos = this.html.length - 1;\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n\n        this.lastCharPos = this.html.length - 1;\n        this.endOfChunkHit = false;\n    }\n\n    advance() {\n        this.pos++;\n\n        if (this.pos > this.lastCharPos) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n\n        let cp = this.html.charCodeAt(this.pos);\n\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (this.skipNextNewLine && cp === $.LINE_FEED) {\n            this.skipNextNewLine = false;\n            this._addGap();\n            return this.advance();\n        }\n\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n\n        this.skipNextNewLine = false;\n\n        if (unicode.isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange =\n            (cp > 0x1f && cp < 0x7f) || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);\n\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n\n        return cp;\n    }\n\n    _checkForProblematicCharacters(cp) {\n        if (unicode.isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        } else if (unicode.isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n\n    retreat() {\n        if (this.pos === this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n\n        this.pos--;\n    }\n}\n\nmodule.exports = Preprocessor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}