{"ast":null,"code":"/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\nimport { track } from './track.js';\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  /** @type {Array<string>} */\n  const results = [];\n  let index = -1;\n  let before = safeOptions.before;\n  indexStack.push(-1);\n  let tracker = track(safeOptions);\n  while (++index < children.length) {\n    const child = children[index];\n    /** @type {string} */\n    let after;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type];\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, context, {\n        before: '',\n        after: '',\n        ...tracker.current()\n      }).charAt(0) : '';\n    } else {\n      after = safeOptions.after;\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n\n      // To do: does this work to reset tracker?\n      tracker = track(safeOptions);\n      tracker.move(results.join(''));\n    }\n    results.push(tracker.move(context.handle(child, parent, context, {\n      ...tracker.current(),\n      before,\n      after\n    })));\n    before = results[results.length - 1].slice(-1);\n  }\n  indexStack.pop();\n  return results.join('');\n}","map":{"version":3,"names":["track","containerPhrasing","parent","context","safeOptions","indexStack","children","results","index","before","push","tracker","length","child","after","handle","handlers","type","peek","current","charAt","replace","move","join","slice","pop"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {track} from './track.js'\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = safeOptions.before\n\n  indexStack.push(-1)\n  let tracker = track(safeOptions)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = track(safeOptions)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,KAAK,QAAO,YAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,iBAAiB,CAACC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAE;EAC9D,MAAMC,UAAU,GAAGF,OAAO,CAACE,UAAU;EACrC,MAAMC,QAAQ,GAAGJ,MAAM,CAACI,QAAQ,IAAI,EAAE;EACtC;EACA,MAAMC,OAAO,GAAG,EAAE;EAClB,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,IAAIC,MAAM,GAAGL,WAAW,CAACK,MAAM;EAE/BJ,UAAU,CAACK,IAAI,CAAC,CAAC,CAAC,CAAC;EACnB,IAAIC,OAAO,GAAGX,KAAK,CAACI,WAAW,CAAC;EAEhC,OAAO,EAAEI,KAAK,GAAGF,QAAQ,CAACM,MAAM,EAAE;IAChC,MAAMC,KAAK,GAAGP,QAAQ,CAACE,KAAK,CAAC;IAC7B;IACA,IAAIM,KAAK;IAETT,UAAU,CAACA,UAAU,CAACO,MAAM,GAAG,CAAC,CAAC,GAAGJ,KAAK;IAEzC,IAAIA,KAAK,GAAG,CAAC,GAAGF,QAAQ,CAACM,MAAM,EAAE;MAC/B;MACA,IAAIG,MAAM,GAAGZ,OAAO,CAACY,MAAM,CAACC,QAAQ,CAACV,QAAQ,CAACE,KAAK,GAAG,CAAC,CAAC,CAACS,IAAI,CAAC;MAC9D,IAAIF,MAAM,IAAIA,MAAM,CAACG,IAAI,EAAEH,MAAM,GAAGA,MAAM,CAACG,IAAI;MAC/CJ,KAAK,GAAGC,MAAM,GACVA,MAAM,CAACT,QAAQ,CAACE,KAAK,GAAG,CAAC,CAAC,EAAEN,MAAM,EAAEC,OAAO,EAAE;QAC3CM,MAAM,EAAE,EAAE;QACVK,KAAK,EAAE,EAAE;QACT,GAAGH,OAAO,CAACQ,OAAO;MACpB,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,GACZ,EAAE;IACR,CAAC,MAAM;MACLN,KAAK,GAAGV,WAAW,CAACU,KAAK;IAC3B;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IACEP,OAAO,CAACK,MAAM,GAAG,CAAC,KACjBH,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,IAAI,CAAC,IACpCI,KAAK,CAACI,IAAI,KAAK,MAAM,EACrB;MACAV,OAAO,CAACA,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,GAAGL,OAAO,CAACA,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAACS,OAAO,CAC/D,aAAa,EACb,GAAG,CACJ;MACDZ,MAAM,GAAG,GAAG;;MAEZ;MACAE,OAAO,GAAGX,KAAK,CAACI,WAAW,CAAC;MAC5BO,OAAO,CAACW,IAAI,CAACf,OAAO,CAACgB,IAAI,CAAC,EAAE,CAAC,CAAC;IAChC;IAEAhB,OAAO,CAACG,IAAI,CACVC,OAAO,CAACW,IAAI,CACVnB,OAAO,CAACY,MAAM,CAACF,KAAK,EAAEX,MAAM,EAAEC,OAAO,EAAE;MACrC,GAAGQ,OAAO,CAACQ,OAAO,EAAE;MACpBV,MAAM;MACNK;IACF,CAAC,CAAC,CACH,CACF;IAEDL,MAAM,GAAGF,OAAO,CAACA,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC;EAChD;EAEAnB,UAAU,CAACoB,GAAG,EAAE;EAEhB,OAAOlB,OAAO,CAACgB,IAAI,CAAC,EAAE,CAAC;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}