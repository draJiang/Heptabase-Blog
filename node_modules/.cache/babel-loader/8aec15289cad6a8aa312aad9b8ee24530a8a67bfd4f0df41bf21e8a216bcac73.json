{"ast":null,"code":"/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded');\nvar ipaddr = require('ipaddr.js');\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n  return addrs;\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n  var trust;\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue;\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n  return compileTrust(compileRangeSubnets(trust));\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n  return rangeSubnets;\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n  var ip = parseip(str);\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n  if (range === null) {\n    range = max;\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n  return [ip, range];\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone() {\n  return false;\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n        trusted = ipconv;\n      }\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var kind = ip.kind();\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n    return ip.match(subnetip, subnetrange);\n  };\n}","map":{"version":3,"names":["module","exports","proxyaddr","all","alladdrs","compile","forwarded","require","ipaddr","DIGIT_REGEXP","isip","isValid","parseip","parse","IP_RANGES","linklocal","loopback","uniquelocal","req","trust","addrs","i","length","val","TypeError","Array","isArray","slice","Object","prototype","hasOwnProperty","call","splice","apply","concat","compileTrust","compileRangeSubnets","arr","rangeSubnets","parseipNotation","len","trustNone","trustSingle","trustMulti","note","pos","lastIndexOf","str","substring","ip","kind","isIPv4MappedAddress","toIPv4Address","max","range","test","parseInt","parseNetmask","netmask","prefixLengthFromSubnetMask","addr","subnets","ipconv","subnet","subnetip","subnetkind","subnetrange","trusted","toIPv4MappedAddress","match","subnetisipv4"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/proxy-addr/index.js"],"sourcesContent":["/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded')\nvar ipaddr = require('ipaddr.js')\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}