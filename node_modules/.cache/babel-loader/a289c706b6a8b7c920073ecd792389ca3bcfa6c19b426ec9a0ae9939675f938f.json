{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\nclass LocationInfoTokenizerMixin extends Mixin {\n  constructor(tokenizer) {\n    super(tokenizer);\n    this.tokenizer = tokenizer;\n    this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n    this.currentAttrLocation = null;\n    this.ctLoc = null;\n  }\n  _getCurrentLocation() {\n    return {\n      startLine: this.posTracker.line,\n      startCol: this.posTracker.col,\n      startOffset: this.posTracker.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n  }\n  _attachCurrentAttrLocationInfo() {\n    this.currentAttrLocation.endLine = this.posTracker.line;\n    this.currentAttrLocation.endCol = this.posTracker.col;\n    this.currentAttrLocation.endOffset = this.posTracker.offset;\n    const currentToken = this.tokenizer.currentToken;\n    const currentAttr = this.tokenizer.currentAttr;\n    if (!currentToken.location.attrs) {\n      currentToken.location.attrs = Object.create(null);\n    }\n    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n  }\n  _getOverriddenMethods(mxn, orig) {\n    const methods = {\n      _createStartTagToken() {\n        orig._createStartTagToken.call(this);\n        this.currentToken.location = mxn.ctLoc;\n      },\n      _createEndTagToken() {\n        orig._createEndTagToken.call(this);\n        this.currentToken.location = mxn.ctLoc;\n      },\n      _createCommentToken() {\n        orig._createCommentToken.call(this);\n        this.currentToken.location = mxn.ctLoc;\n      },\n      _createDoctypeToken(initialName) {\n        orig._createDoctypeToken.call(this, initialName);\n        this.currentToken.location = mxn.ctLoc;\n      },\n      _createCharacterToken(type, ch) {\n        orig._createCharacterToken.call(this, type, ch);\n        this.currentCharacterToken.location = mxn.ctLoc;\n      },\n      _createEOFToken() {\n        orig._createEOFToken.call(this);\n        this.currentToken.location = mxn._getCurrentLocation();\n      },\n      _createAttr(attrNameFirstCh) {\n        orig._createAttr.call(this, attrNameFirstCh);\n        mxn.currentAttrLocation = mxn._getCurrentLocation();\n      },\n      _leaveAttrName(toState) {\n        orig._leaveAttrName.call(this, toState);\n        mxn._attachCurrentAttrLocationInfo();\n      },\n      _leaveAttrValue(toState) {\n        orig._leaveAttrValue.call(this, toState);\n        mxn._attachCurrentAttrLocationInfo();\n      },\n      _emitCurrentToken() {\n        const ctLoc = this.currentToken.location;\n\n        //NOTE: if we have pending character token make it's end location equal to the\n        //current token's start location.\n        if (this.currentCharacterToken) {\n          this.currentCharacterToken.location.endLine = ctLoc.startLine;\n          this.currentCharacterToken.location.endCol = ctLoc.startCol;\n          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n        }\n        if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n          ctLoc.endLine = ctLoc.startLine;\n          ctLoc.endCol = ctLoc.startCol;\n          ctLoc.endOffset = ctLoc.startOffset;\n        } else {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col + 1;\n          ctLoc.endOffset = mxn.posTracker.offset + 1;\n        }\n        orig._emitCurrentToken.call(this);\n      },\n      _emitCurrentCharacterToken() {\n        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n        //then set it's location at the current preprocessor position.\n        //We don't need to increment preprocessor position, since character token\n        //emission is always forced by the start of the next character token here.\n        //So, we already have advanced position.\n        if (ctLoc && ctLoc.endOffset === -1) {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col;\n          ctLoc.endOffset = mxn.posTracker.offset;\n        }\n        orig._emitCurrentCharacterToken.call(this);\n      }\n    };\n\n    //NOTE: patch initial states for each mode to obtain token start position\n    Object.keys(Tokenizer.MODE).forEach(modeName => {\n      const state = Tokenizer.MODE[modeName];\n      methods[state] = function (cp) {\n        mxn.ctLoc = mxn._getCurrentLocation();\n        orig[state].call(this, cp);\n      };\n    });\n    return methods;\n  }\n}\nmodule.exports = LocationInfoTokenizerMixin;","map":{"version":3,"names":["Mixin","require","Tokenizer","PositionTrackingPreprocessorMixin","LocationInfoTokenizerMixin","constructor","tokenizer","posTracker","install","preprocessor","currentAttrLocation","ctLoc","_getCurrentLocation","startLine","line","startCol","col","startOffset","offset","endLine","endCol","endOffset","_attachCurrentAttrLocationInfo","currentToken","currentAttr","location","attrs","Object","create","name","_getOverriddenMethods","mxn","orig","methods","_createStartTagToken","call","_createEndTagToken","_createCommentToken","_createDoctypeToken","initialName","_createCharacterToken","type","ch","currentCharacterToken","_createEOFToken","_createAttr","attrNameFirstCh","_leaveAttrName","toState","_leaveAttrValue","_emitCurrentToken","EOF_TOKEN","_emitCurrentCharacterToken","keys","MODE","forEach","modeName","state","cp","module","exports"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js"],"sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n    constructor(tokenizer) {\n        super(tokenizer);\n\n        this.tokenizer = tokenizer;\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n        this.currentAttrLocation = null;\n        this.ctLoc = null;\n    }\n\n    _getCurrentLocation() {\n        return {\n            startLine: this.posTracker.line,\n            startCol: this.posTracker.col,\n            startOffset: this.posTracker.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n    }\n\n    _attachCurrentAttrLocationInfo() {\n        this.currentAttrLocation.endLine = this.posTracker.line;\n        this.currentAttrLocation.endCol = this.posTracker.col;\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\n\n        const currentToken = this.tokenizer.currentToken;\n        const currentAttr = this.tokenizer.currentAttr;\n\n        if (!currentToken.location.attrs) {\n            currentToken.location.attrs = Object.create(null);\n        }\n\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        const methods = {\n            _createStartTagToken() {\n                orig._createStartTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createEndTagToken() {\n                orig._createEndTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCommentToken() {\n                orig._createCommentToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createDoctypeToken(initialName) {\n                orig._createDoctypeToken.call(this, initialName);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCharacterToken(type, ch) {\n                orig._createCharacterToken.call(this, type, ch);\n                this.currentCharacterToken.location = mxn.ctLoc;\n            },\n\n            _createEOFToken() {\n                orig._createEOFToken.call(this);\n                this.currentToken.location = mxn._getCurrentLocation();\n            },\n\n            _createAttr(attrNameFirstCh) {\n                orig._createAttr.call(this, attrNameFirstCh);\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\n            },\n\n            _leaveAttrName(toState) {\n                orig._leaveAttrName.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _leaveAttrValue(toState) {\n                orig._leaveAttrValue.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _emitCurrentToken() {\n                const ctLoc = this.currentToken.location;\n\n                //NOTE: if we have pending character token make it's end location equal to the\n                //current token's start location.\n                if (this.currentCharacterToken) {\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n                }\n\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n                    ctLoc.endLine = ctLoc.startLine;\n                    ctLoc.endCol = ctLoc.startCol;\n                    ctLoc.endOffset = ctLoc.startOffset;\n                } else {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col + 1;\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\n                }\n\n                orig._emitCurrentToken.call(this);\n            },\n\n            _emitCurrentCharacterToken() {\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n                //then set it's location at the current preprocessor position.\n                //We don't need to increment preprocessor position, since character token\n                //emission is always forced by the start of the next character token here.\n                //So, we already have advanced position.\n                if (ctLoc && ctLoc.endOffset === -1) {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col;\n                    ctLoc.endOffset = mxn.posTracker.offset;\n                }\n\n                orig._emitCurrentCharacterToken.call(this);\n            }\n        };\n\n        //NOTE: patch initial states for each mode to obtain token start position\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\n            const state = Tokenizer.MODE[modeName];\n\n            methods[state] = function(cp) {\n                mxn.ctLoc = mxn._getCurrentLocation();\n                orig[state].call(this, cp);\n            };\n        });\n\n        return methods;\n    }\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}