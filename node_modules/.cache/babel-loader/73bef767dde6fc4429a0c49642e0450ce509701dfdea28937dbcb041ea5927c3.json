{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Token} */\n  let token;\n  while (++index < events.length) {\n    token = events[index][1];\n    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2);\n      token.type = types.data;\n      index++;\n    }\n  }\n  return events;\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n  let token;\n  /** @type {number|undefined} */\n  let open;\n  /** @type {number|undefined} */\n  let close;\n  /** @type {Event[]} */\n  let media;\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1];\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === types.link || token.type === types.labelLink && token._inactive) {\n        break;\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {\n        open = index;\n        if (token.type !== types.labelLink) {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index;\n    }\n  }\n  assert(open !== undefined, '`open` is supposed to be found');\n  assert(close !== undefined, '`close` is supposed to be found');\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]];\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3));\n\n  // Text open.\n  media = push(media, [['enter', text, context]]);\n\n  // Between.\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\n\n  // Text close, marker close, label close.\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]);\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1));\n\n  // Media close.\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n  let labelStart;\n  /** @type {boolean} */\n  let defined;\n\n  // Find an opening.\n  while (index--) {\n    if ((self.events[index][1].type === types.labelImage || self.events[index][1].type === types.labelLink) && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`');\n    if (!labelStart) {\n      return nok(code);\n    }\n\n    // It’s a balanced bracket, but contains a link.\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(types.labelEnd);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelEnd);\n    return afterLabelEnd;\n  }\n\n  /** @type {State} */\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    }\n\n    // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    }\n\n    // Shortcut reference: `[asd]`?\n    return defined ? ok(code) : balanced(code);\n  }\n\n  /** @type {State} */\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren');\n    effects.enter(types.resource);\n    effects.enter(types.resourceMarker);\n    effects.consume(code);\n    effects.exit(types.resourceMarker);\n    return factoryWhitespace(effects, open);\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightParenthesis) {\n      return end(code);\n    }\n    return factoryDestination(effects, destinationAfter, nok, types.resourceDestination, types.resourceDestinationLiteral, types.resourceDestinationLiteralMarker, types.resourceDestinationRaw, types.resourceDestinationString, constants.linkResourceDestinationBalanceMax)(code);\n  }\n\n  /** @type {State} */\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);\n  }\n\n  /** @type {State} */\n  function between(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, factoryWhitespace(effects, end), nok, types.resourceTitle, types.resourceTitleMarker, types.resourceTitleString)(code);\n    }\n    return end(code);\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker);\n      effects.consume(code);\n      effects.exit(types.resourceMarker);\n      effects.exit(types.resource);\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    return factoryLabel.call(self, effects, afterLabel, nok, types.reference, types.referenceMarker, types.referenceString)(code);\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    effects.enter(types.reference);\n    effects.enter(types.referenceMarker);\n    effects.consume(code);\n    effects.exit(types.referenceMarker);\n    return open;\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker);\n      effects.consume(code);\n      effects.exit(types.referenceMarker);\n      effects.exit(types.reference);\n      return ok;\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","codes","constants","types","labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","fullReferenceConstruct","tokenizeFullReference","collapsedReferenceConstruct","tokenizeCollapsedReference","events","index","token","length","type","labelImage","labelLink","data","context","offset","open","close","media","link","_inactive","_balanced","undefined","group","image","start","Object","assign","end","label","text","labelText","slice","parser","constructs","insideSpan","null","effects","nok","self","labelStart","defined","code","rightSquareBracket","balanced","includes","sliceSerialize","now","enter","labelMarker","consume","exit","afterLabelEnd","leftParenthesis","attempt","leftSquareBracket","resource","resourceMarker","rightParenthesis","destinationAfter","resourceDestination","resourceDestinationLiteral","resourceDestinationLiteralMarker","resourceDestinationRaw","resourceDestinationString","linkResourceDestinationBalanceMax","between","quotationMark","apostrophe","resourceTitle","resourceTitleMarker","resourceTitleString","call","afterLabel","reference","referenceMarker","referenceString"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst fullReferenceConstruct = {tokenize: tokenizeFullReference}\n/** @type {Construct} */\nconst collapsedReferenceConstruct = {tokenize: tokenizeCollapsedReference}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2)\n      token.type = types.data\n      index++\n    }\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number|undefined} */\n  let open\n  /** @type {number|undefined} */\n  let close\n  /** @type {Event[]} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink) &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink) &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // It’s a balanced bracket, but contains a link.\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return afterLabelEnd\n  }\n\n  /** @type {State} */\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    }\n\n    // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    }\n\n    // Shortcut reference: `[asd]`?\n    return defined ? ok(code) : balanced(code)\n  }\n\n  /** @type {State} */\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return factoryWhitespace(effects, open)\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightParenthesis) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /** @type {State} */\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  /** @type {State} */\n  function between(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}