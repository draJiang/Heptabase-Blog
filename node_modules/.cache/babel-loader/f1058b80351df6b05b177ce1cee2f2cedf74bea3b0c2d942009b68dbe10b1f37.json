{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n\n/** @type {Resolver} */\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n  let inHead;\n  /** @type {boolean|undefined} */\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n  let inRow;\n  /** @type {number|undefined} */\n  let contentStart;\n  /** @type {number|undefined} */\n  let contentEnd;\n  /** @type {number|undefined} */\n  let cellStart;\n  /** @type {boolean|undefined} */\n  let seenCellInRow;\n  while (++index < events.length) {\n    const token = events[index][1];\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n      if (\n      // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        };\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== types.whitespace))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n  return events;\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n  let hasDash;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow');\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    }\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent');\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space');\n    return inCellContentHead(code);\n  }\n\n  /** @type {State} */\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n\n  /** @type {State} */\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n\n  /** @type {State} */\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    effects.exit(types.whitespace);\n    return cellBreakHead(code);\n  }\n\n  /** @type {State} */\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeHead : inCellContentHead;\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentHead;\n    }\n\n    // Anything else.\n    return inCellContentHead(code);\n  }\n\n  /** @type {State} */\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n\n  /** @type {State} */\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n    effects.exit(types.whitespace);\n    return atDelimiterRowBreak(code);\n  }\n\n  /** @type {State} */\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n    effects.exit('tableDelimiterFiller');\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n    return atDelimiterRowBreak(code);\n  }\n\n  /** @type {State} */\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    }\n\n    // Anything else is not ok.\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow');\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n    if (code === codes.eof) {\n      return tableClose(code);\n    }\n    assert(markdownLineEnding(code), 'expected eol');\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize), tableClose))(code);\n  }\n\n  /** @type {State} */\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n\n  /** @type {State} */\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n\n  /** @type {State} */\n  function rowStartBody(code) {\n    effects.enter('tableRow');\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    }\n    effects.enter('temporaryTableCellContent');\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code);\n  }\n\n  /** @type {State} */\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n\n  /** @type {State} */\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n\n  /** @type {State} */\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n    effects.exit(types.whitespace);\n    return cellBreakBody(code);\n  }\n\n  /** @type {State} */\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeBody : inCellContentBody;\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentBody;\n    }\n\n    // Anything else.\n    return inCellContentBody(code);\n  }\n\n  /** @type {State} */\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n    if (code === codes.eof) {\n      return tableBodyClose(code);\n    }\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, types.linePrefix, constants.tabSize), tableBodyClose))(code);\n  }\n\n  /** @type {State} */\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return factorySpace(effects, prefixed, types.linePrefix);\n    }\n\n    /** @type {State} */\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === codes.eof || markdownLineEnding(code)) {\n        return nok(code);\n      }\n      const tail = self.events[self.events.length - 1];\n\n      // Indented code can interrupt delimiter and body rows.\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {\n        return nok(code);\n      }\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check');\n    // EOL.\n    effects.consume(code);\n    return whitespace;\n  }\n\n  /** @type {State} */\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code);\n      size++;\n      return size === constants.tabSize ? ok : whitespace;\n    }\n\n    // EOF or whitespace\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    }\n\n    // Anything else.\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","chunkText","contentType","contentTypeText","splice","undefined","whitespace","cell","effects","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","verticalBar","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","eof","atRowEndHead","inWhitespaceHead","backslash","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","dash","push","inFillerDelimiter","colon","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","linePrefix","tabSize","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","lineEnding","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","virtualSpace","space"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {null: {tokenize: tokenizeTable, resolve: resolveTable}}\n}\n\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n  let inHead\n  /** @type {boolean|undefined} */\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n  let inRow\n  /** @type {number|undefined} */\n  let contentStart\n  /** @type {number|undefined} */\n  let contentEnd\n  /** @type {number|undefined} */\n  let cellStart\n  /** @type {boolean|undefined} */\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        }\n\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== types.whitespace)))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n  let hasDash\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  /** @type {State} */\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakHead(code)\n  }\n\n  /** @type {State} */\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeHead\n      : inCellContentHead\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {tokenize: tokenizeRowEnd, partial: true},\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n\n  /** @type {State} */\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit(types.whitespace)\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === codes.eof) {\n      return tableClose(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize),\n        tableClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  /** @type {State} */\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  /** @type {State} */\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakBody(code)\n  }\n\n  /** @type {State} */\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeBody\n      : inCellContentBody\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === codes.eof) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(\n          effects,\n          rowStartBody,\n          types.linePrefix,\n          constants.tabSize\n        ),\n        tableBodyClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return factorySpace(effects, prefixed, types.linePrefix)\n    }\n\n    /** @type {State} */\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === codes.eof ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1]\n\n      // Indented code can interrupt delimiter and body rows.\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === types.linePrefix &&\n        tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  /** @type {State} */\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code)\n      size++\n      return size === constants.tabSize ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}