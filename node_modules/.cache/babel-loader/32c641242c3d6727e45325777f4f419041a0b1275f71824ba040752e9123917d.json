{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n};\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>|undefined} */\n  let marker;\n  /** @type {string} */\n  let buffer;\n  /** @type {number} */\n  let index;\n  /** @type {State} */\n  let returnState;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlText);\n    effects.enter(types.htmlTextData);\n    effects.consume(code);\n    return open;\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instruction;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentOpen;\n    }\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      buffer = constants.cdataOpeningString;\n      index = 0;\n      return cdataOpen;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function commentOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentStart;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function commentStart(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code);\n    }\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentStartDash;\n    }\n    return comment(code);\n  }\n\n  /** @type {State} */\n  function commentStartDash(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code);\n    }\n    return comment(code);\n  }\n\n  /** @type {State} */\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment;\n      return atLineEnding(code);\n    }\n    effects.consume(code);\n    return comment;\n  }\n\n  /** @type {State} */\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return end;\n    }\n    return comment(code);\n  }\n\n  /** @type {State} */\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? cdata : cdataOpen;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata;\n      return atLineEnding(code);\n    }\n    effects.consume(code);\n    return cdata;\n  }\n\n  /** @type {State} */\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n\n  /** @type {State} */\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n\n  /** @type {State} */\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration;\n      return atLineEnding(code);\n    }\n    effects.consume(code);\n    return declaration;\n  }\n\n  /** @type {State} */\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instructionClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction;\n      return atLineEnding(code);\n    }\n    effects.consume(code);\n    return instruction;\n  }\n\n  /** @type {State} */\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code);\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function tagClose(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return tagCloseBetween(code);\n  }\n\n  /** @type {State} */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween;\n      return atLineEnding(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n    return end(code);\n  }\n\n  /** @type {State} */\n  function tagOpen(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return end;\n    }\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween;\n      return atLineEnding(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n    return end(code);\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    return tagOpenAttributeNameAfter(code);\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return atLineEnding(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n    return tagOpenBetween(code);\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return atLineEnding(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    effects.consume(code);\n    marker = undefined;\n    return tagOpenAttributeValueUnquoted;\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return tagOpenAttributeValueQuotedAfter;\n    }\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return atLineEnding(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === codes.greaterThan || code === codes.slash || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n\n  // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n  /** @type {State} */\n  function atLineEnding(code) {\n    assert(returnState, 'expected return state');\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit(types.htmlTextData);\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return factorySpace(effects, afterPrefix, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n  }\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    effects.enter(types.htmlTextData);\n    return returnState(code);\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      effects.exit(types.htmlTextData);\n      effects.exit(types.htmlText);\n      return ok;\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","htmlText","name","tokenize","tokenizeHtmlText","effects","nok","self","marker","buffer","index","returnState","start","code","lessThan","enter","htmlTextData","consume","open","exclamationMark","declarationOpen","slash","tagCloseStart","questionMark","instruction","tagOpen","dash","commentOpen","leftSquareBracket","cdataOpeningString","cdataOpen","declaration","commentStart","eof","greaterThan","commentStartDash","comment","commentClose","atLineEnding","end","charCodeAt","length","cdata","rightSquareBracket","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","colon","underscore","tagOpenAttributeName","dot","tagOpenAttributeNameAfter","equalsTo","tagOpenAttributeValueBefore","graveAccent","quotationMark","apostrophe","tagOpenAttributeValueQuoted","undefined","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","exit","lineEnding","afterPrefix","linePrefix","parser","constructs","disable","null","includes","tabSize"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/html-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>|undefined} */\n  let marker\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlText)\n    effects.enter(types.htmlTextData)\n    effects.consume(code)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      buffer = constants.cdataOpeningString\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentStart(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function commentStartDash(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  /** @type {State} */\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  /** @type {State} */\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /** @type {State} */\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /** @type {State} */\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  /** @type {State} */\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  /** @type {State} */\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code)\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagClose(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  /** @type {State} */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function tagOpen(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeName(code) {\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.greaterThan ||\n      code === codes.slash ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n  /** @type {State} */\n  function atLineEnding(code) {\n    assert(returnState, 'expected return state')\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit(types.htmlTextData)\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )\n  }\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    effects.enter(types.htmlTextData)\n    return returnState(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      effects.exit(types.htmlTextData)\n      effects.exit(types.htmlText)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,EAAE,IAAIC,MAAM,QAAO,YAAY;AACvC,SAAQC,YAAY,QAAO,yBAAyB;AACpD,SACEC,UAAU,EACVC,iBAAiB,EACjBC,kBAAkB,EAClBC,yBAAyB,EACzBC,aAAa,QACR,0BAA0B;AACjC,SAAQC,KAAK,QAAO,gCAAgC;AACpD,SAAQC,SAAS,QAAO,oCAAoC;AAC5D,SAAQC,KAAK,QAAO,gCAAgC;;AAEpD;AACA,OAAO,MAAMC,QAAQ,GAAG;EAACC,IAAI,EAAE,UAAU;EAAEC,QAAQ,EAAEC;AAAgB,CAAC;;AAEtE;AACA,SAASA,gBAAgB,CAACC,OAAO,EAAEf,EAAE,EAAEgB,GAAG,EAAE;EAC1C,MAAMC,IAAI,GAAG,IAAI;EACjB;EACA,IAAIC,MAAM;EACV;EACA,IAAIC,MAAM;EACV;EACA,IAAIC,KAAK;EACT;EACA,IAAIC,WAAW;EAEf,OAAOC,KAAK;;EAEZ;EACA,SAASA,KAAK,CAACC,IAAI,EAAE;IACnBtB,MAAM,CAACsB,IAAI,KAAKf,KAAK,CAACgB,QAAQ,EAAE,cAAc,CAAC;IAC/CT,OAAO,CAACU,KAAK,CAACf,KAAK,CAACC,QAAQ,CAAC;IAC7BI,OAAO,CAACU,KAAK,CAACf,KAAK,CAACgB,YAAY,CAAC;IACjCX,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAOK,IAAI;EACb;;EAEA;EACA,SAASA,IAAI,CAACL,IAAI,EAAE;IAClB,IAAIA,IAAI,KAAKf,KAAK,CAACqB,eAAe,EAAE;MAClCd,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOO,eAAe;IACxB;IAEA,IAAIP,IAAI,KAAKf,KAAK,CAACuB,KAAK,EAAE;MACxBhB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOS,aAAa;IACtB;IAEA,IAAIT,IAAI,KAAKf,KAAK,CAACyB,YAAY,EAAE;MAC/BlB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOW,WAAW;IACpB;IAEA,IAAI/B,UAAU,CAACoB,IAAI,CAAC,EAAE;MACpBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOY,OAAO;IAChB;IAEA,OAAOnB,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASO,eAAe,CAACP,IAAI,EAAE;IAC7B,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,EAAE;MACvBrB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOc,WAAW;IACpB;IAEA,IAAId,IAAI,KAAKf,KAAK,CAAC8B,iBAAiB,EAAE;MACpCvB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrBJ,MAAM,GAAGV,SAAS,CAAC8B,kBAAkB;MACrCnB,KAAK,GAAG,CAAC;MACT,OAAOoB,SAAS;IAClB;IAEA,IAAIrC,UAAU,CAACoB,IAAI,CAAC,EAAE;MACpBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOkB,WAAW;IACpB;IAEA,OAAOzB,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASc,WAAW,CAACd,IAAI,EAAE;IACzB,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,EAAE;MACvBrB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOmB,YAAY;IACrB;IAEA,OAAO1B,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASmB,YAAY,CAACnB,IAAI,EAAE;IAC1B,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,IAAIpB,IAAI,KAAKf,KAAK,CAACoC,WAAW,EAAE;MACpD,OAAO5B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,EAAE;MACvBrB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOsB,gBAAgB;IACzB;IAEA,OAAOC,OAAO,CAACvB,IAAI,CAAC;EACtB;;EAEA;EACA,SAASsB,gBAAgB,CAACtB,IAAI,EAAE;IAC9B,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,IAAIpB,IAAI,KAAKf,KAAK,CAACoC,WAAW,EAAE;MACpD,OAAO5B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,OAAOuB,OAAO,CAACvB,IAAI,CAAC;EACtB;;EAEA;EACA,SAASuB,OAAO,CAACvB,IAAI,EAAE;IACrB,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,EAAE;MACtB,OAAO3B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,EAAE;MACvBrB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOwB,YAAY;IACrB;IAEA,IAAI1C,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGyB,OAAO;MACrB,OAAOE,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAOuB,OAAO;EAChB;;EAEA;EACA,SAASC,YAAY,CAACxB,IAAI,EAAE;IAC1B,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,EAAE;MACvBrB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAO0B,GAAG;IACZ;IAEA,OAAOH,OAAO,CAACvB,IAAI,CAAC;EACtB;;EAEA;EACA,SAASiB,SAAS,CAACjB,IAAI,EAAE;IACvB,IAAIA,IAAI,KAAKJ,MAAM,CAAC+B,UAAU,CAAC9B,KAAK,EAAE,CAAC,EAAE;MACvCL,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOH,KAAK,KAAKD,MAAM,CAACgC,MAAM,GAAGC,KAAK,GAAGZ,SAAS;IACpD;IAEA,OAAOxB,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAAS6B,KAAK,CAAC7B,IAAI,EAAE;IACnB,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,EAAE;MACtB,OAAO3B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAAC6C,kBAAkB,EAAE;MACrCtC,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAO+B,UAAU;IACnB;IAEA,IAAIjD,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAG+B,KAAK;MACnB,OAAOJ,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAO6B,KAAK;EACd;;EAEA;EACA,SAASE,UAAU,CAAC/B,IAAI,EAAE;IACxB,IAAIA,IAAI,KAAKf,KAAK,CAAC6C,kBAAkB,EAAE;MACrCtC,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOgC,QAAQ;IACjB;IAEA,OAAOH,KAAK,CAAC7B,IAAI,CAAC;EACpB;;EAEA;EACA,SAASgC,QAAQ,CAAChC,IAAI,EAAE;IACtB,IAAIA,IAAI,KAAKf,KAAK,CAACoC,WAAW,EAAE;MAC9B,OAAOK,GAAG,CAAC1B,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAAC6C,kBAAkB,EAAE;MACrCtC,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOgC,QAAQ;IACjB;IAEA,OAAOH,KAAK,CAAC7B,IAAI,CAAC;EACpB;;EAEA;EACA,SAASkB,WAAW,CAAClB,IAAI,EAAE;IACzB,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,IAAIpB,IAAI,KAAKf,KAAK,CAACoC,WAAW,EAAE;MACpD,OAAOK,GAAG,CAAC1B,IAAI,CAAC;IAClB;IAEA,IAAIlB,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGoB,WAAW;MACzB,OAAOO,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAOkB,WAAW;EACpB;;EAEA;EACA,SAASP,WAAW,CAACX,IAAI,EAAE;IACzB,IAAIA,IAAI,KAAKf,KAAK,CAACmC,GAAG,EAAE;MACtB,OAAO3B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAACyB,YAAY,EAAE;MAC/BlB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOiC,gBAAgB;IACzB;IAEA,IAAInD,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGa,WAAW;MACzB,OAAOc,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAOW,WAAW;EACpB;;EAEA;EACA,SAASsB,gBAAgB,CAACjC,IAAI,EAAE;IAC9B,OAAOA,IAAI,KAAKf,KAAK,CAACoC,WAAW,GAAGK,GAAG,CAAC1B,IAAI,CAAC,GAAGW,WAAW,CAACX,IAAI,CAAC;EACnE;;EAEA;EACA,SAASS,aAAa,CAACT,IAAI,EAAE;IAC3B,IAAIpB,UAAU,CAACoB,IAAI,CAAC,EAAE;MACpBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOkC,QAAQ;IACjB;IAEA,OAAOzC,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASkC,QAAQ,CAAClC,IAAI,EAAE;IACtB,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,IAAIhC,iBAAiB,CAACmB,IAAI,CAAC,EAAE;MAClDR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOkC,QAAQ;IACjB;IAEA,OAAOC,eAAe,CAACnC,IAAI,CAAC;EAC9B;;EAEA;EACA,SAASmC,eAAe,CAACnC,IAAI,EAAE;IAC7B,IAAIlB,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGqC,eAAe;MAC7B,OAAOV,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEA,IAAIhB,aAAa,CAACgB,IAAI,CAAC,EAAE;MACvBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOmC,eAAe;IACxB;IAEA,OAAOT,GAAG,CAAC1B,IAAI,CAAC;EAClB;;EAEA;EACA,SAASY,OAAO,CAACZ,IAAI,EAAE;IACrB,IAAIA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,IAAIhC,iBAAiB,CAACmB,IAAI,CAAC,EAAE;MAClDR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOY,OAAO;IAChB;IAEA,IACEZ,IAAI,KAAKf,KAAK,CAACuB,KAAK,IACpBR,IAAI,KAAKf,KAAK,CAACoC,WAAW,IAC1BtC,yBAAyB,CAACiB,IAAI,CAAC,EAC/B;MACA,OAAOoC,cAAc,CAACpC,IAAI,CAAC;IAC7B;IAEA,OAAOP,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASoC,cAAc,CAACpC,IAAI,EAAE;IAC5B,IAAIA,IAAI,KAAKf,KAAK,CAACuB,KAAK,EAAE;MACxBhB,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAO0B,GAAG;IACZ;IAEA,IAAI1B,IAAI,KAAKf,KAAK,CAACoD,KAAK,IAAIrC,IAAI,KAAKf,KAAK,CAACqD,UAAU,IAAI1D,UAAU,CAACoB,IAAI,CAAC,EAAE;MACzER,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOuC,oBAAoB;IAC7B;IAEA,IAAIzD,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGsC,cAAc;MAC5B,OAAOX,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEA,IAAIhB,aAAa,CAACgB,IAAI,CAAC,EAAE;MACvBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOoC,cAAc;IACvB;IAEA,OAAOV,GAAG,CAAC1B,IAAI,CAAC;EAClB;;EAEA;EACA,SAASuC,oBAAoB,CAACvC,IAAI,EAAE;IAClC,IACEA,IAAI,KAAKf,KAAK,CAAC4B,IAAI,IACnBb,IAAI,KAAKf,KAAK,CAACuD,GAAG,IAClBxC,IAAI,KAAKf,KAAK,CAACoD,KAAK,IACpBrC,IAAI,KAAKf,KAAK,CAACqD,UAAU,IACzBzD,iBAAiB,CAACmB,IAAI,CAAC,EACvB;MACAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOuC,oBAAoB;IAC7B;IAEA,OAAOE,yBAAyB,CAACzC,IAAI,CAAC;EACxC;;EAEA;EACA,SAASyC,yBAAyB,CAACzC,IAAI,EAAE;IACvC,IAAIA,IAAI,KAAKf,KAAK,CAACyD,QAAQ,EAAE;MAC3BlD,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAO2C,2BAA2B;IACpC;IAEA,IAAI7D,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAG2C,yBAAyB;MACvC,OAAOhB,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEA,IAAIhB,aAAa,CAACgB,IAAI,CAAC,EAAE;MACvBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOyC,yBAAyB;IAClC;IAEA,OAAOL,cAAc,CAACpC,IAAI,CAAC;EAC7B;;EAEA;EACA,SAAS2C,2BAA2B,CAAC3C,IAAI,EAAE;IACzC,IACEA,IAAI,KAAKf,KAAK,CAACmC,GAAG,IAClBpB,IAAI,KAAKf,KAAK,CAACgB,QAAQ,IACvBD,IAAI,KAAKf,KAAK,CAACyD,QAAQ,IACvB1C,IAAI,KAAKf,KAAK,CAACoC,WAAW,IAC1BrB,IAAI,KAAKf,KAAK,CAAC2D,WAAW,EAC1B;MACA,OAAOnD,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAAC4D,aAAa,IAAI7C,IAAI,KAAKf,KAAK,CAAC6D,UAAU,EAAE;MAC7DtD,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrBL,MAAM,GAAGK,IAAI;MACb,OAAO+C,2BAA2B;IACpC;IAEA,IAAIjE,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAG6C,2BAA2B;MACzC,OAAOlB,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEA,IAAIhB,aAAa,CAACgB,IAAI,CAAC,EAAE;MACvBR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAO2C,2BAA2B;IACpC;IAEAnD,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrBL,MAAM,GAAGqD,SAAS;IAClB,OAAOC,6BAA6B;EACtC;;EAEA;EACA,SAASF,2BAA2B,CAAC/C,IAAI,EAAE;IACzC,IAAIA,IAAI,KAAKL,MAAM,EAAE;MACnBH,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrB,OAAOkD,gCAAgC;IACzC;IAEA,IAAIlD,IAAI,KAAKf,KAAK,CAACmC,GAAG,EAAE;MACtB,OAAO3B,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIlB,kBAAkB,CAACkB,IAAI,CAAC,EAAE;MAC5BF,WAAW,GAAGiD,2BAA2B;MACzC,OAAOtB,YAAY,CAACzB,IAAI,CAAC;IAC3B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAO+C,2BAA2B;EACpC;;EAEA;EACA,SAASG,gCAAgC,CAAClD,IAAI,EAAE;IAC9C,IACEA,IAAI,KAAKf,KAAK,CAACoC,WAAW,IAC1BrB,IAAI,KAAKf,KAAK,CAACuB,KAAK,IACpBzB,yBAAyB,CAACiB,IAAI,CAAC,EAC/B;MACA,OAAOoC,cAAc,CAACpC,IAAI,CAAC;IAC7B;IAEA,OAAOP,GAAG,CAACO,IAAI,CAAC;EAClB;;EAEA;EACA,SAASiD,6BAA6B,CAACjD,IAAI,EAAE;IAC3C,IACEA,IAAI,KAAKf,KAAK,CAACmC,GAAG,IAClBpB,IAAI,KAAKf,KAAK,CAAC4D,aAAa,IAC5B7C,IAAI,KAAKf,KAAK,CAAC6D,UAAU,IACzB9C,IAAI,KAAKf,KAAK,CAACgB,QAAQ,IACvBD,IAAI,KAAKf,KAAK,CAACyD,QAAQ,IACvB1C,IAAI,KAAKf,KAAK,CAAC2D,WAAW,EAC1B;MACA,OAAOnD,GAAG,CAACO,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKf,KAAK,CAACoC,WAAW,IAAItC,yBAAyB,CAACiB,IAAI,CAAC,EAAE;MACjE,OAAOoC,cAAc,CAACpC,IAAI,CAAC;IAC7B;IAEAR,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrB,OAAOiD,6BAA6B;EACtC;;EAEA;EACA;EACA;EACA,SAASxB,YAAY,CAACzB,IAAI,EAAE;IAC1BtB,MAAM,CAACoB,WAAW,EAAE,uBAAuB,CAAC;IAC5CpB,MAAM,CAACI,kBAAkB,CAACkB,IAAI,CAAC,EAAE,cAAc,CAAC;IAChDR,OAAO,CAAC2D,IAAI,CAAChE,KAAK,CAACgB,YAAY,CAAC;IAChCX,OAAO,CAACU,KAAK,CAACf,KAAK,CAACiE,UAAU,CAAC;IAC/B5D,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;IACrBR,OAAO,CAAC2D,IAAI,CAAChE,KAAK,CAACiE,UAAU,CAAC;IAC9B,OAAOzE,YAAY,CACjBa,OAAO,EACP6D,WAAW,EACXlE,KAAK,CAACmE,UAAU,EAChB5D,IAAI,CAAC6D,MAAM,CAACC,UAAU,CAACC,OAAO,CAACC,IAAI,CAACC,QAAQ,CAAC,cAAc,CAAC,GACxDX,SAAS,GACT9D,SAAS,CAAC0E,OAAO,CACtB;EACH;;EAEA;EACA,SAASP,WAAW,CAACrD,IAAI,EAAE;IACzBR,OAAO,CAACU,KAAK,CAACf,KAAK,CAACgB,YAAY,CAAC;IACjC,OAAOL,WAAW,CAACE,IAAI,CAAC;EAC1B;;EAEA;EACA,SAAS0B,GAAG,CAAC1B,IAAI,EAAE;IACjB,IAAIA,IAAI,KAAKf,KAAK,CAACoC,WAAW,EAAE;MAC9B7B,OAAO,CAACY,OAAO,CAACJ,IAAI,CAAC;MACrBR,OAAO,CAAC2D,IAAI,CAAChE,KAAK,CAACgB,YAAY,CAAC;MAChCX,OAAO,CAAC2D,IAAI,CAAChE,KAAK,CAACC,QAAQ,CAAC;MAC5B,OAAOX,EAAE;IACX;IAEA,OAAOgB,GAAG,CAACO,IAAI,CAAC;EAClB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}