{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:json');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\n * Module exports.\n */\n\nmodule.exports = json;\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/; // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json(options) {\n  var opts = options || {};\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {};\n    }\n    if (strict) {\n      var first = firstchar(body);\n      if (first !== '{' && first !== '[') {\n        debug('strict violation');\n        throw createStrictSyntaxError(body, first);\n      }\n    }\n    try {\n      debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      });\n    }\n  }\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8';\n    if (charset.slice(0, 4) !== 'utf-') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = index !== -1 ? str.substring(0, index) + '#' : '';\n  try {\n    JSON.parse(partial); /* istanbul ignore next */\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    });\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar(str) {\n  var match = FIRST_CHAR_REGEXP.exec(str);\n  return match ? match[1] : undefined;\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message);\n  error.message = obj.message;\n  return error;\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","createError","debug","read","typeis","module","exports","json","FIRST_CHAR_REGEXP","options","opts","limit","parse","inflate","reviver","strict","type","verify","TypeError","shouldParse","typeChecker","body","length","first","firstchar","createStrictSyntaxError","JSON","e","normalizeJsonSyntaxError","message","stack","jsonParser","req","res","next","_body","hasBody","headers","charset","getCharset","slice","toUpperCase","encoding","str","char","index","indexOf","partial","substring","SyntaxError","replace","match","exec","undefined","parameters","toLowerCase","error","obj","keys","Object","getOwnPropertyNames","i","key","checkType","Boolean"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/body-parser/lib/types/json.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/ // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json (options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw createStrictSyntaxError(body, first)\n      }\n    }\n\n    try {\n      debug('parse json')\n      return JSON.parse(body, reviver)\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      })\n    }\n  }\n\n  return function jsonParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.slice(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError (str, char) {\n  var index = str.indexOf(char)\n  var partial = index !== -1\n    ? str.substring(0, index) + '#'\n    : ''\n\n  try {\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar (str) {\n  var match = FIRST_CHAR_REGEXP.exec(str)\n\n  return match\n    ? match[1]\n    : undefined\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError (error, obj) {\n  var keys = Object.getOwnPropertyNames(error)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key]\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message)\n  error.message = obj.message\n\n  return error\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}