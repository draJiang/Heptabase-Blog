{"ast":null,"code":"/**\n * Expose `pathtoRegexp`.\n */\n\nmodule.exports = pathtoRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n    return path;\n  }\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?')).replace(/\\/\\(/g, '/(?:').replace(/([\\/\\.])/g, '\\\\$1').replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n    slash = slash || '';\n    format = format || '';\n    capture = capture || '([^\\\\/' + format + ']+?)';\n    optional = optional || '';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\\\/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  }).replace(/\\*/g, function (star, index) {\n    var len = keys.length;\n    while (len-- > keysOffset && keys[len].offset > index) {\n      keys[len].offset += 3; // Replacement length minus asterisk length.\n    }\n\n    return '(.*)';\n  });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    }\n\n    // It's possible to escape the bracket.\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n    i++;\n  }\n\n  // If the path is non-ending, match until the end or a slash.\n  path += end ? '$' : path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)';\n  return new RegExp(path, flags);\n}\n;","map":{"version":3,"names":["module","exports","pathtoRegexp","MATCHING_GROUP_REGEXP","path","keys","options","strict","end","flags","sensitive","extraOffset","keysOffset","length","i","name","m","RegExp","exec","source","push","optional","offset","index","Array","isArray","map","value","join","replace","match","slash","format","key","capture","star","result","len","escapeCount","charAt","splice"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/path-to-regexp/index.js"],"sourcesContent":["/**\n * Expose `pathtoRegexp`.\n */\n\nmodule.exports = pathtoRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n    .replace(/\\/\\(/g, '/(?:')\n    .replace(/([\\/\\.])/g, '\\\\$1')\n    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n      slash = slash || '';\n      format = format || '';\n      capture = capture || '([^\\\\/' + format + ']+?)';\n      optional = optional || '';\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + format + (optional ? slash : '') + capture\n        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    })\n    .replace(/\\*/g, function (star, index) {\n      var len = keys.length\n\n      while (len-- > keysOffset && keys[len].offset > index) {\n        keys[len].offset += 3; // Replacement length minus asterisk length.\n      }\n\n      return '(.*)';\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    }\n\n    // It's possible to escape the bracket.\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  // If the path is non-ending, match until the end or a slash.\n  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\n  return new RegExp(path, flags);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}