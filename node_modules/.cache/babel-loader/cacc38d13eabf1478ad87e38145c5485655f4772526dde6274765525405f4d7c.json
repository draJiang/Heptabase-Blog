{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js';\nimport { pointStart, pointEnd } from 'unist-util-position';\nimport { visit } from 'unist-util-visit';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { toParse5 } from 'hast-util-to-parse5';\nimport { htmlVoidElements } from 'html-void-elements';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nconst inTemplateMode = 'IN_TEMPLATE_MODE';\nconst dataState = 'DATA_STATE';\nconst characterToken = 'CHARACTER_TOKEN';\nconst startTagToken = 'START_TAG_TOKEN';\nconst endTagToken = 'END_TAG_TOKEN';\nconst commentToken = 'COMMENT_TOKEN';\nconst doctypeToken = 'DOCTYPE_TOKEN';\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nexport const raw =\n/**\n * @type {(\n *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n *   ((tree: Node, options?: Options) => Node)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {VFile} [file]\n * @param {Options} [options]\n */\nfunction (tree, file, options) {\n  let index = -1;\n  const parser = new Parser(parseOptions);\n  const one = zwitch('type', {\n    // @ts-expect-error: hush.\n    handlers: {\n      root,\n      element,\n      text,\n      comment,\n      doctype,\n      raw: handleRaw\n    },\n    // @ts-expect-error: hush.\n    unknown\n  });\n  /** @type {boolean|undefined} */\n  let stitches;\n  /** @type {HiddenTokenizer|undefined} */\n  let tokenizer;\n  /** @type {HiddenPreprocessor|undefined} */\n  let preprocessor;\n  /** @type {HiddenPosTracker|undefined} */\n  let posTracker;\n  /** @type {HiddenLocationTracker|undefined} */\n  let locationTracker;\n  if (isOptions(file)) {\n    options = file;\n    file = undefined;\n  }\n  if (options && options.passThrough) {\n    while (++index < options.passThrough.length) {\n      // @ts-expect-error: hush.\n      one.handlers[options.passThrough[index]] = stitch;\n    }\n  }\n  const result = fromParse5(documentMode(tree) ? document() : fragment(), file);\n  if (stitches) {\n    visit(result, 'comment', (node, index, parent) => {\n      const stitch = /** @type {Stitch} */ /** @type {unknown} */node;\n      if (stitch.value.stitch && parent !== null && index !== null) {\n        // @ts-expect-error: assume the stitch is allowed.\n        parent.children[index] = stitch.value.stitch;\n        return index;\n      }\n    });\n  }\n\n  // Unpack if possible and when not given a `root`.\n  if (tree.type !== 'root' && result.type === 'root' && result.children.length === 1) {\n    return result.children[0];\n  }\n  return result;\n\n  /**\n   * @returns {P5Fragment}\n   */\n  function fragment() {\n    /** @type {P5Element} */\n    const context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Element} */\n    const mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Fragment} */\n    const doc = {\n      nodeName: '#document-fragment',\n      childNodes: []\n    };\n    parser._bootstrap(mock, context);\n    parser._pushTmplInsertionMode(inTemplateMode);\n    parser._initTokenizerForFragmentParsing();\n    parser._insertFakeRootElement();\n    parser._resetInsertionMode();\n    parser._findFormInFragmentContext();\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n    parser._adoptNodes(mock.childNodes[0], doc);\n    return doc;\n  }\n\n  /**\n   * @returns {P5Document}\n   */\n  function document() {\n    /** @type {P5Document} */\n    const doc = parser.treeAdapter.createDocument();\n    parser._bootstrap(doc, undefined);\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n    return doc;\n  }\n\n  /**\n   * @param {Array<Content>} nodes\n   * @returns {void}\n   */\n  function all(nodes) {\n    let index = -1;\n\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index]);\n      }\n    }\n  }\n\n  /**\n   * @param {Root} node\n   * @returns {void}\n   */\n  function root(node) {\n    all(node.children);\n  }\n\n  /**\n   * @param {Element} node\n   * @returns {void}\n   */\n  function element(node) {\n    resetTokenizer();\n    parser._processToken(startTag(node), webNamespaces.html);\n    all(node.children);\n    if (!htmlVoidElements.includes(node.tagName)) {\n      resetTokenizer();\n      parser._processToken(endTag(node));\n    }\n  }\n\n  /**\n   * @param {Text} node\n   * @returns {void}\n   */\n  function text(node) {\n    resetTokenizer();\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    });\n  }\n\n  /**\n   * @param {Doctype} node\n   * @returns {void}\n   */\n  function doctype(node) {\n    resetTokenizer();\n    parser._processToken({\n      type: doctypeToken,\n      name: 'html',\n      forceQuirks: false,\n      publicId: '',\n      systemId: '',\n      location: createParse5Location(node)\n    });\n  }\n\n  /**\n   * @param {Comment|Stitch} node\n   * @returns {void}\n   */\n  function comment(node) {\n    resetTokenizer();\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    });\n  }\n\n  /**\n   * @param {Raw} node\n   * @returns {void}\n   */\n  function handleRaw(node) {\n    const start = pointStart(node);\n    const line = start.line || 1;\n    const column = start.column || 1;\n    const offset = start.offset || 0;\n\n    /* c8 ignore next 4 */\n    if (!preprocessor) throw new Error('Expected `preprocessor`');\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`');\n    if (!locationTracker) throw new Error('Expected `locationTracker`');\n\n    // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n    preprocessor.html = undefined;\n    preprocessor.pos = -1;\n    preprocessor.lastGapPos = -1;\n    preprocessor.lastCharPos = -1;\n    preprocessor.gapStack = [];\n    preprocessor.skipNextNewLine = false;\n    preprocessor.lastChunkWritten = false;\n    preprocessor.endOfChunkHit = false;\n\n    // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n    posTracker.isEol = false;\n    posTracker.lineStartPos = -column + 1; // Looks weird, but ensures we get correct positional info.\n    posTracker.droppedBufferSize = offset;\n    posTracker.offset = 0;\n    posTracker.col = 1;\n    posTracker.line = line;\n\n    // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n    locationTracker.currentAttrLocation = undefined;\n    locationTracker.ctLoc = createParse5Location(node);\n\n    // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n    tokenizer.write(node.value);\n    parser._runParsingLoop(null);\n\n    // Character references hang, so if we ended there, we need to flush\n    // those too.\n    // We reset the preprocessor as if the document ends here.\n    // Then one single call to the relevant state does the trick, parse5\n    // consumes the whole token.\n    if (tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' || tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE') {\n      preprocessor.lastChunkWritten = true;\n      tokenizer[tokenizer.state](tokenizer._consume());\n    }\n  }\n\n  /**\n   * @param {Node} node\n   */\n  function stitch(node) {\n    stitches = true;\n\n    /** @type {Node} */\n    let clone;\n\n    // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n    if ('children' in node) {\n      clone = {\n        ...node,\n        children: raw({\n          type: 'root',\n          children: node.children\n        }, file, options\n        // @ts-expect-error Assume a given parent yields a parent.\n        ).children\n      };\n    } else {\n      clone = {\n        ...node\n      };\n    }\n\n    // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    comment({\n      type: 'comment',\n      value: {\n        stitch: clone\n      }\n    });\n  }\n  function resetTokenizer() {\n    /* c8 ignore next 2 */\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`');\n\n    // Process final characters if they’re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n    const token = tokenizer.currentCharacterToken;\n    if (token) {\n      token.location.endLine = posTracker.line;\n      token.location.endCol = posTracker.col + 1;\n      token.location.endOffset = posTracker.offset + 1;\n      parser._processToken(token);\n    }\n\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    tokenizer.tokenQueue = [];\n    tokenizer.state = dataState;\n    tokenizer.returnState = '';\n    tokenizer.charRefCode = -1;\n    tokenizer.tempBuff = [];\n    tokenizer.lastStartTagName = '';\n    tokenizer.consumedAfterSnapshot = -1;\n    tokenizer.active = false;\n    tokenizer.currentCharacterToken = undefined;\n    tokenizer.currentToken = undefined;\n    tokenizer.currentAttr = undefined;\n  }\n};\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node));\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location);\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  };\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs;\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node));\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location);\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  };\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node');\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node;\n  return Boolean(head && (head.type === 'doctype' || head.type === 'element' && head.tagName === 'html'));\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node);\n  const end = pointEnd(node);\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value));\n}","map":{"version":3,"names":["Parser","pointStart","pointEnd","visit","fromParse5","toParse5","htmlVoidElements","webNamespaces","zwitch","inTemplateMode","dataState","characterToken","startTagToken","endTagToken","commentToken","doctypeToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","file","options","index","parser","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","stitches","tokenizer","preprocessor","posTracker","locationTracker","isOptions","undefined","passThrough","length","stitch","result","documentMode","document","fragment","node","parent","value","children","type","context","nodeName","tagName","attrs","namespaceURI","html","childNodes","mock","doc","_bootstrap","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","Error","__mixins","resetTokenizer","_adoptNodes","treeAdapter","createDocument","all","nodes","_processToken","startTag","includes","endTag","chars","location","createParse5Location","name","forceQuirks","publicId","systemId","data","start","line","column","offset","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","state","_consume","clone","token","currentCharacterToken","endLine","endCol","endOffset","tokenQueue","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","Object","assign","selfClosing","attributes","properties","head","Boolean","end","startLine","startCol","startOffset"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/hast-util-raw/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js'\nimport {pointStart, pointEnd} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nexport const raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new Parser(parseOptions)\n      const one = zwitch('type', {\n        // @ts-expect-error: hush.\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = fromParse5(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        visit(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processToken(startTag(node), webNamespaces.html)\n\n        all(node.children)\n\n        if (!htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = pointStart(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if they’re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAOA,MAAM,MAAM,4BAA4B;AAC/C,SAAQC,UAAU,EAAEC,QAAQ,QAAO,qBAAqB;AACxD,SAAQC,KAAK,QAAO,kBAAkB;AACtC,SAAQC,UAAU,QAAO,uBAAuB;AAChD,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,gBAAgB,QAAO,oBAAoB;AACnD,SAAQC,aAAa,QAAO,gBAAgB;AAC5C,SAAQC,MAAM,QAAO,QAAQ;AAE7B,MAAMC,cAAc,GAAG,kBAAkB;AACzC,MAAMC,SAAS,GAAG,YAAY;AAC9B,MAAMC,cAAc,GAAG,iBAAiB;AACxC,MAAMC,aAAa,GAAG,iBAAiB;AACvC,MAAMC,WAAW,GAAG,eAAe;AACnC,MAAMC,YAAY,GAAG,eAAe;AACpC,MAAMC,YAAY,GAAG,eAAe;;AAEpC;AACA,MAAMC,YAAY,GAAG;EAACC,sBAAsB,EAAE,IAAI;EAAEC,gBAAgB,EAAE;AAAK,CAAC;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG;AACd;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,UAAUC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC7B,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,MAAMC,MAAM,GAAG,IAAIxB,MAAM,CAACgB,YAAY,CAAC;EACvC,MAAMS,GAAG,GAAGjB,MAAM,CAAC,MAAM,EAAE;IACzB;IACAkB,QAAQ,EAAE;MAACC,IAAI;MAAEC,OAAO;MAAEC,IAAI;MAAEC,OAAO;MAAEC,OAAO;MAAEZ,GAAG,EAAEa;IAAS,CAAC;IACjE;IACAC;EACF,CAAC,CAAC;EACF;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,SAAS;EACb;EACA,IAAIC,YAAY;EAChB;EACA,IAAIC,UAAU;EACd;EACA,IAAIC,eAAe;EAEnB,IAAIC,SAAS,CAAClB,IAAI,CAAC,EAAE;IACnBC,OAAO,GAAGD,IAAI;IACdA,IAAI,GAAGmB,SAAS;EAClB;EAEA,IAAIlB,OAAO,IAAIA,OAAO,CAACmB,WAAW,EAAE;IAClC,OAAO,EAAElB,KAAK,GAAGD,OAAO,CAACmB,WAAW,CAACC,MAAM,EAAE;MAC3C;MACAjB,GAAG,CAACC,QAAQ,CAACJ,OAAO,CAACmB,WAAW,CAAClB,KAAK,CAAC,CAAC,GAAGoB,MAAM;IACnD;EACF;EAEA,MAAMC,MAAM,GAAGxC,UAAU,CACvByC,YAAY,CAACzB,IAAI,CAAC,GAAG0B,QAAQ,EAAE,GAAGC,QAAQ,EAAE,EAC5C1B,IAAI,CACL;EAED,IAAIa,QAAQ,EAAE;IACZ/B,KAAK,CAACyC,MAAM,EAAE,SAAS,EAAE,CAACI,IAAI,EAAEzB,KAAK,EAAE0B,MAAM,KAAK;MAChD,MAAMN,MAAM,GAAG,sBAAuB,sBAAwBK,IAAM;MACpE,IAAIL,MAAM,CAACO,KAAK,CAACP,MAAM,IAAIM,MAAM,KAAK,IAAI,IAAI1B,KAAK,KAAK,IAAI,EAAE;QAC5D;QACA0B,MAAM,CAACE,QAAQ,CAAC5B,KAAK,CAAC,GAAGoB,MAAM,CAACO,KAAK,CAACP,MAAM;QAC5C,OAAOpB,KAAK;MACd;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,IACEH,IAAI,CAACgC,IAAI,KAAK,MAAM,IACpBR,MAAM,CAACQ,IAAI,KAAK,MAAM,IACtBR,MAAM,CAACO,QAAQ,CAACT,MAAM,KAAK,CAAC,EAC5B;IACA,OAAOE,MAAM,CAACO,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA,OAAOP,MAAM;;EAEb;AACN;AACA;EACM,SAASG,QAAQ,GAAG;IAClB;IACA,MAAMM,OAAO,GAAG;MACdC,QAAQ,EAAE,UAAU;MACpBC,OAAO,EAAE,UAAU;MACnBC,KAAK,EAAE,EAAE;MACTC,YAAY,EAAElD,aAAa,CAACmD,IAAI;MAChCC,UAAU,EAAE;IACd,CAAC;IACD;IACA,MAAMC,IAAI,GAAG;MACXN,QAAQ,EAAE,cAAc;MACxBC,OAAO,EAAE,cAAc;MACvBC,KAAK,EAAE,EAAE;MACTC,YAAY,EAAElD,aAAa,CAACmD,IAAI;MAChCC,UAAU,EAAE;IACd,CAAC;IACD;IACA,MAAME,GAAG,GAAG;MAACP,QAAQ,EAAE,oBAAoB;MAAEK,UAAU,EAAE;IAAE,CAAC;IAE5DnC,MAAM,CAACsC,UAAU,CAACF,IAAI,EAAEP,OAAO,CAAC;IAChC7B,MAAM,CAACuC,sBAAsB,CAACtD,cAAc,CAAC;IAC7Ce,MAAM,CAACwC,gCAAgC,EAAE;IACzCxC,MAAM,CAACyC,sBAAsB,EAAE;IAC/BzC,MAAM,CAAC0C,mBAAmB,EAAE;IAC5B1C,MAAM,CAAC2C,0BAA0B,EAAE;IAEnChC,SAAS,GAAGX,MAAM,CAACW,SAAS;IAC5B;IACA,IAAI,CAACA,SAAS,EAAE,MAAM,IAAIiC,KAAK,CAAC,sBAAsB,CAAC;IACvDhC,YAAY,GAAGD,SAAS,CAACC,YAAY;IACrCE,eAAe,GAAGH,SAAS,CAACkC,QAAQ,CAAC,CAAC,CAAC;IACvChC,UAAU,GAAGC,eAAe,CAACD,UAAU;IAEvCZ,GAAG,CAACL,IAAI,CAAC;IAETkD,cAAc,EAAE;IAEhB9C,MAAM,CAAC+C,WAAW,CAACX,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,EAAEE,GAAG,CAAC;IAE3C,OAAOA,GAAG;EACZ;;EAEA;AACN;AACA;EACM,SAASf,QAAQ,GAAG;IAClB;IACA,MAAMe,GAAG,GAAGrC,MAAM,CAACgD,WAAW,CAACC,cAAc,EAAE;IAE/CjD,MAAM,CAACsC,UAAU,CAACD,GAAG,EAAErB,SAAS,CAAC;IACjCL,SAAS,GAAGX,MAAM,CAACW,SAAS;IAC5B;IACA,IAAI,CAACA,SAAS,EAAE,MAAM,IAAIiC,KAAK,CAAC,sBAAsB,CAAC;IACvDhC,YAAY,GAAGD,SAAS,CAACC,YAAY;IACrCE,eAAe,GAAGH,SAAS,CAACkC,QAAQ,CAAC,CAAC,CAAC;IACvChC,UAAU,GAAGC,eAAe,CAACD,UAAU;IAEvCZ,GAAG,CAACL,IAAI,CAAC;IAETkD,cAAc,EAAE;IAEhB,OAAOT,GAAG;EACZ;;EAEA;AACN;AACA;AACA;EACM,SAASa,GAAG,CAACC,KAAK,EAAE;IAClB,IAAIpD,KAAK,GAAG,CAAC,CAAC;;IAEd;IACA,IAAIoD,KAAK,EAAE;MACT,OAAO,EAAEpD,KAAK,GAAGoD,KAAK,CAACjC,MAAM,EAAE;QAC7BjB,GAAG,CAACkD,KAAK,CAACpD,KAAK,CAAC,CAAC;MACnB;IACF;EACF;;EAEA;AACN;AACA;AACA;EACM,SAASI,IAAI,CAACqB,IAAI,EAAE;IAClB0B,GAAG,CAAC1B,IAAI,CAACG,QAAQ,CAAC;EACpB;;EAEA;AACN;AACA;AACA;EACM,SAASvB,OAAO,CAACoB,IAAI,EAAE;IACrBsB,cAAc,EAAE;IAChB9C,MAAM,CAACoD,aAAa,CAACC,QAAQ,CAAC7B,IAAI,CAAC,EAAEzC,aAAa,CAACmD,IAAI,CAAC;IAExDgB,GAAG,CAAC1B,IAAI,CAACG,QAAQ,CAAC;IAElB,IAAI,CAAC7C,gBAAgB,CAACwE,QAAQ,CAAC9B,IAAI,CAACO,OAAO,CAAC,EAAE;MAC5Ce,cAAc,EAAE;MAChB9C,MAAM,CAACoD,aAAa,CAACG,MAAM,CAAC/B,IAAI,CAAC,CAAC;IACpC;EACF;;EAEA;AACN;AACA;AACA;EACM,SAASnB,IAAI,CAACmB,IAAI,EAAE;IAClBsB,cAAc,EAAE;IAChB9C,MAAM,CAACoD,aAAa,CAAC;MACnBxB,IAAI,EAAEzC,cAAc;MACpBqE,KAAK,EAAEhC,IAAI,CAACE,KAAK;MACjB+B,QAAQ,EAAEC,oBAAoB,CAAClC,IAAI;IACrC,CAAC,CAAC;EACJ;;EAEA;AACN;AACA;AACA;EACM,SAASjB,OAAO,CAACiB,IAAI,EAAE;IACrBsB,cAAc,EAAE;IAChB9C,MAAM,CAACoD,aAAa,CAAC;MACnBxB,IAAI,EAAErC,YAAY;MAClBoE,IAAI,EAAE,MAAM;MACZC,WAAW,EAAE,KAAK;MAClBC,QAAQ,EAAE,EAAE;MACZC,QAAQ,EAAE,EAAE;MACZL,QAAQ,EAAEC,oBAAoB,CAAClC,IAAI;IACrC,CAAC,CAAC;EACJ;;EAEA;AACN;AACA;AACA;EACM,SAASlB,OAAO,CAACkB,IAAI,EAAE;IACrBsB,cAAc,EAAE;IAChB9C,MAAM,CAACoD,aAAa,CAAC;MACnBxB,IAAI,EAAEtC,YAAY;MAClByE,IAAI,EAAEvC,IAAI,CAACE,KAAK;MAChB+B,QAAQ,EAAEC,oBAAoB,CAAClC,IAAI;IACrC,CAAC,CAAC;EACJ;;EAEA;AACN;AACA;AACA;EACM,SAAShB,SAAS,CAACgB,IAAI,EAAE;IACvB,MAAMwC,KAAK,GAAGvF,UAAU,CAAC+C,IAAI,CAAC;IAC9B,MAAMyC,IAAI,GAAGD,KAAK,CAACC,IAAI,IAAI,CAAC;IAC5B,MAAMC,MAAM,GAAGF,KAAK,CAACE,MAAM,IAAI,CAAC;IAChC,MAAMC,MAAM,GAAGH,KAAK,CAACG,MAAM,IAAI,CAAC;;IAEhC;IACA,IAAI,CAACvD,YAAY,EAAE,MAAM,IAAIgC,KAAK,CAAC,yBAAyB,CAAC;IAC7D,IAAI,CAACjC,SAAS,EAAE,MAAM,IAAIiC,KAAK,CAAC,sBAAsB,CAAC;IACvD,IAAI,CAAC/B,UAAU,EAAE,MAAM,IAAI+B,KAAK,CAAC,uBAAuB,CAAC;IACzD,IAAI,CAAC9B,eAAe,EAAE,MAAM,IAAI8B,KAAK,CAAC,4BAA4B,CAAC;;IAEnE;IACA;IACAhC,YAAY,CAACsB,IAAI,GAAGlB,SAAS;IAC7BJ,YAAY,CAACwD,GAAG,GAAG,CAAC,CAAC;IACrBxD,YAAY,CAACyD,UAAU,GAAG,CAAC,CAAC;IAC5BzD,YAAY,CAAC0D,WAAW,GAAG,CAAC,CAAC;IAC7B1D,YAAY,CAAC2D,QAAQ,GAAG,EAAE;IAC1B3D,YAAY,CAAC4D,eAAe,GAAG,KAAK;IACpC5D,YAAY,CAAC6D,gBAAgB,GAAG,KAAK;IACrC7D,YAAY,CAAC8D,aAAa,GAAG,KAAK;;IAElC;IACA;IACA7D,UAAU,CAAC8D,KAAK,GAAG,KAAK;IACxB9D,UAAU,CAAC+D,YAAY,GAAG,CAACV,MAAM,GAAG,CAAC,EAAC;IACtCrD,UAAU,CAACgE,iBAAiB,GAAGV,MAAM;IACrCtD,UAAU,CAACsD,MAAM,GAAG,CAAC;IACrBtD,UAAU,CAACiE,GAAG,GAAG,CAAC;IAClBjE,UAAU,CAACoD,IAAI,GAAGA,IAAI;;IAEtB;IACA;IACAnD,eAAe,CAACiE,mBAAmB,GAAG/D,SAAS;IAC/CF,eAAe,CAACkE,KAAK,GAAGtB,oBAAoB,CAAClC,IAAI,CAAC;;IAElD;IACA;IACAb,SAAS,CAACsE,KAAK,CAACzD,IAAI,CAACE,KAAK,CAAC;IAC3B1B,MAAM,CAACkF,eAAe,CAAC,IAAI,CAAC;;IAE5B;IACA;IACA;IACA;IACA;IACA,IACEvE,SAAS,CAACwE,KAAK,KAAK,iCAAiC,IACrDxE,SAAS,CAACwE,KAAK,KAAK,uCAAuC,EAC3D;MACAvE,YAAY,CAAC6D,gBAAgB,GAAG,IAAI;MACpC9D,SAAS,CAACA,SAAS,CAACwE,KAAK,CAAC,CAACxE,SAAS,CAACyE,QAAQ,EAAE,CAAC;IAClD;EACF;;EAEA;AACN;AACA;EACM,SAASjE,MAAM,CAACK,IAAI,EAAE;IACpBd,QAAQ,GAAG,IAAI;;IAEf;IACA,IAAI2E,KAAK;;IAET;IACA;IACA,IAAI,UAAU,IAAI7D,IAAI,EAAE;MACtB6D,KAAK,GAAG;QACN,GAAG7D,IAAI;QACPG,QAAQ,EAAEhC,GAAG,CACX;UAACiC,IAAI,EAAE,MAAM;UAAED,QAAQ,EAAEH,IAAI,CAACG;QAAQ,CAAC,EACvC9B,IAAI,EACJC;QACA;QAAA,CACD,CAAC6B;MACJ,CAAC;IACH,CAAC,MAAM;MACL0D,KAAK,GAAG;QAAC,GAAG7D;MAAI,CAAC;IACnB;;IAEA;IACA;IACA;IACAlB,OAAO,CAAC;MAACsB,IAAI,EAAE,SAAS;MAAEF,KAAK,EAAE;QAACP,MAAM,EAAEkE;MAAK;IAAC,CAAC,CAAC;EACpD;EAEA,SAASvC,cAAc,GAAG;IACxB;IACA,IAAI,CAACnC,SAAS,EAAE,MAAM,IAAIiC,KAAK,CAAC,sBAAsB,CAAC;IACvD,IAAI,CAAC/B,UAAU,EAAE,MAAM,IAAI+B,KAAK,CAAC,uBAAuB,CAAC;;IAEzD;IACA;IACA;IACA,MAAM0C,KAAK,GAAG3E,SAAS,CAAC4E,qBAAqB;IAE7C,IAAID,KAAK,EAAE;MACTA,KAAK,CAAC7B,QAAQ,CAAC+B,OAAO,GAAG3E,UAAU,CAACoD,IAAI;MACxCqB,KAAK,CAAC7B,QAAQ,CAACgC,MAAM,GAAG5E,UAAU,CAACiE,GAAG,GAAG,CAAC;MAC1CQ,KAAK,CAAC7B,QAAQ,CAACiC,SAAS,GAAG7E,UAAU,CAACsD,MAAM,GAAG,CAAC;MAChDnE,MAAM,CAACoD,aAAa,CAACkC,KAAK,CAAC;IAC7B;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA3E,SAAS,CAACgF,UAAU,GAAG,EAAE;IACzBhF,SAAS,CAACwE,KAAK,GAAGjG,SAAS;IAC3ByB,SAAS,CAACiF,WAAW,GAAG,EAAE;IAC1BjF,SAAS,CAACkF,WAAW,GAAG,CAAC,CAAC;IAC1BlF,SAAS,CAACmF,QAAQ,GAAG,EAAE;IACvBnF,SAAS,CAACoF,gBAAgB,GAAG,EAAE;IAC/BpF,SAAS,CAACqF,qBAAqB,GAAG,CAAC,CAAC;IACpCrF,SAAS,CAACsF,MAAM,GAAG,KAAK;IACxBtF,SAAS,CAAC4E,qBAAqB,GAAGvE,SAAS;IAC3CL,SAAS,CAACuF,YAAY,GAAGlF,SAAS;IAClCL,SAAS,CAACwF,WAAW,GAAGnF,SAAS;EACnC;AACF,CACD;AACH;AACA;AACA;AACA;AACA,SAASqC,QAAQ,CAAC7B,IAAI,EAAE;EACtB;EACA,MAAMiC,QAAQ,GAAG2C,MAAM,CAACC,MAAM,CAAC3C,oBAAoB,CAAClC,IAAI,CAAC,CAAC;EAC1D;EACAiC,QAAQ,CAACJ,QAAQ,GAAG+C,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE5C,QAAQ,CAAC;;EAE/C;EACA,OAAO;IACL7B,IAAI,EAAExC,aAAa;IACnB2C,OAAO,EAAEP,IAAI,CAACO,OAAO;IACrBuE,WAAW,EAAE,KAAK;IAClBtE,KAAK,EAAEuE,UAAU,CAAC/E,IAAI,CAAC;IACvBiC;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAAS8C,UAAU,CAAC/E,IAAI,EAAE;EACxB,OAAO3C,QAAQ,CAAC;IACdkD,OAAO,EAAEP,IAAI,CAACO,OAAO;IACrBH,IAAI,EAAE,SAAS;IACf4E,UAAU,EAAEhF,IAAI,CAACgF,UAAU;IAC3B7E,QAAQ,EAAE;IACV;EACF,CAAC,CAAC,CAACK,KAAK;AACV;;AAEA;AACA;AACA;AACA;AACA,SAASuB,MAAM,CAAC/B,IAAI,EAAE;EACpB;EACA,MAAMiC,QAAQ,GAAG2C,MAAM,CAACC,MAAM,CAAC3C,oBAAoB,CAAClC,IAAI,CAAC,CAAC;EAC1D;EACAiC,QAAQ,CAACJ,QAAQ,GAAG+C,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE5C,QAAQ,CAAC;;EAE/C;EACA,OAAO;IACL7B,IAAI,EAAEvC,WAAW;IACjB0C,OAAO,EAAEP,IAAI,CAACO,OAAO;IACrBC,KAAK,EAAE,EAAE;IACTyB;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA,SAAShD,OAAO,CAACe,IAAI,EAAE;EACrB,MAAM,IAAIoB,KAAK,CAAC,kBAAkB,GAAGpB,IAAI,CAACI,IAAI,GAAG,QAAQ,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA,SAASP,YAAY,CAACG,IAAI,EAAE;EAC1B,MAAMiF,IAAI,GAAGjF,IAAI,CAACI,IAAI,KAAK,MAAM,GAAGJ,IAAI,CAACG,QAAQ,CAAC,CAAC,CAAC,GAAGH,IAAI;EAC3D,OAAOkF,OAAO,CACZD,IAAI,KACDA,IAAI,CAAC7E,IAAI,KAAK,SAAS,IACrB6E,IAAI,CAAC7E,IAAI,KAAK,SAAS,IAAI6E,IAAI,CAAC1E,OAAO,KAAK,MAAO,CAAC,CAC1D;AACH;;AAEA;AACA;AACA;AACA;AACA,SAAS2B,oBAAoB,CAAClC,IAAI,EAAE;EAClC,MAAMwC,KAAK,GAAGvF,UAAU,CAAC+C,IAAI,CAAC;EAC9B,MAAMmF,GAAG,GAAGjI,QAAQ,CAAC8C,IAAI,CAAC;EAE1B,OAAO;IACLoF,SAAS,EAAE5C,KAAK,CAACC,IAAI;IACrB4C,QAAQ,EAAE7C,KAAK,CAACE,MAAM;IACtB4C,WAAW,EAAE9C,KAAK,CAACG,MAAM;IACzBqB,OAAO,EAAEmB,GAAG,CAAC1C,IAAI;IACjBwB,MAAM,EAAEkB,GAAG,CAACzC,MAAM;IAClBwB,SAAS,EAAEiB,GAAG,CAACxC;EACjB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAASpD,SAAS,CAACW,KAAK,EAAE;EACxB,OAAOgF,OAAO,CAAChF,KAAK,IAAI,EAAE,SAAS,IAAIA,KAAK,IAAI,UAAU,IAAIA,KAAK,CAAC,CAAC;AACvE"},"metadata":{},"sourceType":"module","externalDependencies":[]}