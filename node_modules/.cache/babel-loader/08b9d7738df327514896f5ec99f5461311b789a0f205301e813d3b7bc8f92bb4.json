{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\n\nexport var u =\n/**\n* @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n*/\n/**\n * @param {string} type Type of node\n * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n * @param {ChildrenOrValue} [value] `children` or `value` of node\n * @returns {Node}\n */\nfunction (type, props, value) {\n  /** @type {Node} */\n  var node = {\n    type: String(type)\n  };\n  if ((value === undefined || value === null) && (typeof props === 'string' || Array.isArray(props))) {\n    value = props;\n  } else {\n    Object.assign(node, props);\n  }\n  if (Array.isArray(value)) {\n    node.children = value;\n  } else if (value !== undefined && value !== null) {\n    node.value = String(value);\n  }\n  return node;\n};","map":{"version":3,"names":["u","type","props","value","node","String","undefined","Array","isArray","Object","assign","children"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/unist-builder/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\n\nexport var u = /**\n * @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n */ (\n  /**\n   * @param {string} type Type of node\n   * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n   * @param {ChildrenOrValue} [value] `children` or `value` of node\n   * @returns {Node}\n   */\n  function (type, props, value) {\n    /** @type {Node} */\n    var node = {type: String(type)}\n\n    if (\n      (value === undefined || value === null) &&\n      (typeof props === 'string' || Array.isArray(props))\n    ) {\n      value = props\n    } else {\n      Object.assign(node, props)\n    }\n\n    if (Array.isArray(value)) {\n      node.children = value\n    } else if (value !== undefined && value !== null) {\n      node.value = String(value)\n    }\n\n    return node\n  }\n)\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIA,CAAC;AAAG;AACf;AACA;AACE;AACF;AACA;AACA;AACA;AACA;AACE,UAAUC,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAE;EAC5B;EACA,IAAIC,IAAI,GAAG;IAACH,IAAI,EAAEI,MAAM,CAACJ,IAAI;EAAC,CAAC;EAE/B,IACE,CAACE,KAAK,KAAKG,SAAS,IAAIH,KAAK,KAAK,IAAI,MACrC,OAAOD,KAAK,KAAK,QAAQ,IAAIK,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,CAAC,EACnD;IACAC,KAAK,GAAGD,KAAK;EACf,CAAC,MAAM;IACLO,MAAM,CAACC,MAAM,CAACN,IAAI,EAAEF,KAAK,CAAC;EAC5B;EAEA,IAAIK,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,EAAE;IACxBC,IAAI,CAACO,QAAQ,GAAGR,KAAK;EACvB,CAAC,MAAM,IAAIA,KAAK,KAAKG,SAAS,IAAIH,KAAK,KAAK,IAAI,EAAE;IAChDC,IAAI,CAACD,KAAK,GAAGE,MAAM,CAACF,KAAK,CAAC;EAC5B;EAEA,OAAOC,IAAI;AACb,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}