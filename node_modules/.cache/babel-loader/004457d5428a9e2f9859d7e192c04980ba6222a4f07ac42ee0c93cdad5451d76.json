{"ast":null,"code":"/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\nmodule.exports = onFinished;\nmodule.exports.isFinished = isFinished;\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar asyncHooks = tryRequireAsyncHooks();\nvar first = require('ee-first');\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg);\n    return msg;\n  }\n\n  // attach the listener to the message\n  attachListener(msg, wrap(listener));\n  return msg;\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket;\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  }\n\n  // don't know\n  return undefined;\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return;\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish);\n  }\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket);\n  if (msg.socket === undefined) {\n    // istanbul ignore next: node.js 0.8 patch\n    patchAssignSocket(msg, onSocket);\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished;\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg);\n    attachFinishedListener(msg, attached);\n  }\n  attached.queue.push(listener);\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n  listener.queue = [];\n  return listener;\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\n// istanbul ignore next: node.js 0.8 patch\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return;\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}\n\n/**\n * Try to require async_hooks\n * @private\n */\n\nfunction tryRequireAsyncHooks() {\n  try {\n    return require('async_hooks');\n  } catch (e) {\n    return {};\n  }\n}\n\n/**\n * Wrap function with async resource, if possible.\n * AsyncResource.bind static method backported.\n * @private\n */\n\nfunction wrap(fn) {\n  var res;\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn;\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null);\n}","map":{"version":3,"names":["module","exports","onFinished","isFinished","asyncHooks","tryRequireAsyncHooks","first","require","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","msg","listener","attachListener","wrap","socket","finished","Boolean","writable","complete","upgrade","readable","undefined","attachFinishedListener","callback","eeMsg","eeSocket","onFinish","error","cancel","onSocket","removeListener","on","patchAssignSocket","attached","__onFinished","queue","createListener","push","err","i","length","res","assignSocket","_assignSocket","call","e","AsyncResource","name","runInAsyncScope"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/on-finished/index.js"],"sourcesContent":["/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar asyncHooks = tryRequireAsyncHooks()\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished (msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, wrap(listener))\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished (msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener (msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish (error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket (socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // istanbul ignore next: node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener (msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener (msg) {\n  function listener (err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\n// istanbul ignore next: node.js 0.8 patch\nfunction patchAssignSocket (res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket (socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n\n/**\n * Try to require async_hooks\n * @private\n */\n\nfunction tryRequireAsyncHooks () {\n  try {\n    return require('async_hooks')\n  } catch (e) {\n    return {}\n  }\n}\n\n/**\n * Wrap function with async resource, if possible.\n * AsyncResource.bind static method backported.\n * @private\n */\n\nfunction wrap (fn) {\n  var res\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}