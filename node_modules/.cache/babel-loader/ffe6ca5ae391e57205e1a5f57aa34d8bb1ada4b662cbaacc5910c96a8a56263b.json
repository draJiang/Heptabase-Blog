{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n  if (!codecOptions) throw new Error(\"SBCS codec is called without the data.\");\n\n  // Prepare char buffer for decoding.\n  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\";\n    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);\n    codecOptions.chars = asciiString + codecOptions.chars;\n  }\n  this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n\n  // Encoding buffer.\n  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n  for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n  this.encodeBuf = encodeBuf;\n}\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\nfunction SBCSEncoder(options, codec) {\n  this.encodeBuf = codec.encodeBuf;\n}\nSBCSEncoder.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length);\n  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];\n  return buf;\n};\nSBCSEncoder.prototype.end = function () {};\nfunction SBCSDecoder(options, codec) {\n  this.decodeBuf = codec.decodeBuf;\n}\nSBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf;\n  var newBuf = Buffer.alloc(buf.length * 2);\n  var idx1 = 0,\n    idx2 = 0;\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = decodeBuf[idx1];\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];\n  }\n  return newBuf.toString('ucs2');\n};\nSBCSDecoder.prototype.end = function () {};","map":{"version":3,"names":["Buffer","require","exports","_sbcs","SBCSCodec","codecOptions","iconv","Error","chars","length","type","asciiString","i","String","fromCharCode","decodeBuf","from","encodeBuf","alloc","defaultCharSingleByte","charCodeAt","prototype","encoder","SBCSEncoder","decoder","SBCSDecoder","options","codec","write","str","buf","end","newBuf","idx1","idx2","toString"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/body-parser/node_modules/iconv-lite/encodings/sbcs-codec.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n    if (!codecOptions)\n        throw new Error(\"SBCS codec is called without the data.\")\n    \n    // Prepare char buffer for decoding.\n    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))\n        throw new Error(\"Encoding '\"+codecOptions.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n    \n    if (codecOptions.chars.length === 128) {\n        var asciiString = \"\";\n        for (var i = 0; i < 128; i++)\n            asciiString += String.fromCharCode(i);\n        codecOptions.chars = asciiString + codecOptions.chars;\n    }\n\n    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n    \n    // Encoding buffer.\n    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n    for (var i = 0; i < codecOptions.chars.length; i++)\n        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n    this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\n\nfunction SBCSEncoder(options, codec) {\n    this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length);\n    for (var i = 0; i < str.length; i++)\n        buf[i] = this.encodeBuf[str.charCodeAt(i)];\n    \n    return buf;\n}\n\nSBCSEncoder.prototype.end = function() {\n}\n\n\nfunction SBCSDecoder(options, codec) {\n    this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function(buf) {\n    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n    var decodeBuf = this.decodeBuf;\n    var newBuf = Buffer.alloc(buf.length*2);\n    var idx1 = 0, idx2 = 0;\n    for (var i = 0; i < buf.length; i++) {\n        idx1 = buf[i]*2; idx2 = i*2;\n        newBuf[idx2] = decodeBuf[idx1];\n        newBuf[idx2+1] = decodeBuf[idx1+1];\n    }\n    return newBuf.toString('ucs2');\n}\n\nSBCSDecoder.prototype.end = function() {\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}