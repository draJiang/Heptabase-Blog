{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n  GB18030_CODE = -2,\n  SEQ_START = -10,\n  NODE_START = -1000,\n  UNASSIGNED_NODE = new Array(0x100),\n  DEF_CHAR = -1;\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n  // Load tables.\n  var mappingTable = codecOptions.table();\n\n  // Decode tables: MBCS -> Unicode.\n\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n  this.decodeTableSeq = [];\n\n  // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);\n  this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n  // Encode tables: Unicode -> DBCS.\n\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n  this.encodeTable = [];\n\n  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n  this.encodeTableSeq = [];\n\n  // Some chars can be decoded, but need not be encoded.\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  }\n\n  // Use decode trie to recursively fill out encode tables.\n  this._fillEncodeTable(0, 0, skipEncodeChars);\n\n  // Add more encoding pairs when needed.\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n  // Load & create GB18030 tables when needed.\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n    // Add GB18030 decode tables.\n    var thirdByteNodeIdx = this.decodeTables.length;\n    var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    var fourthByteNodeIdx = this.decodeTables.length;\n    var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n      var secondByteNode = this.decodeTables[secondByteNodeIdx];\n      for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n    }\n    for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n    for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;\n  }\n}\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n  for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n  return node;\n};\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16);\n\n  // Choose the decoding node where we'll write our chars.\n  var writeTable = this._getDecodeTrieNode(curAddr);\n  curAddr = curAddr & 0xFF;\n\n  // Write all other elements of the chunk to the table.\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n};\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n  return this.encodeTable[high];\n};\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  var node;\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  }\n\n  // Traverse the character tree, allocating new nodes as needed.\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  }\n\n  // Set the leaf to given dbcsCode.\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n  }\n};\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined;\n\n  // Static data\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n    leadSurrogate = this.leadSurrogate,\n    seqObj = this.seqObj,\n    nextChar = -1,\n    i = 0,\n    j = 0;\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    }\n\n    // 1. Handle surrogates.\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode;\n          // Double lead surrogate found.\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n      leadSurrogate = -1;\n    }\n\n    // 2. Convert uCode character.\n    var dbcsCode = UNASSIGNED;\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {\n          // TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    }\n\n    // 3. Write dbcsCode character.\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n    j = 0;\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {\n      // See todo above.\n    }\n    this.seqObj = undefined;\n  }\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n  return newBuf.slice(0, j);\n};\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBuf = Buffer.alloc(0);\n\n  // Static data\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n    nodeIdx = this.nodeIdx,\n    prevBuf = this.prevBuf,\n    prevBufOffset = this.prevBuf.length,\n    seqStart = -this.prevBuf.length,\n    // idx of the start of current parsed sequence.\n    uCode;\n  if (prevBufOffset > 0)\n    // Make prev buf overlap a little to make it easier to slice later.\n    prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];\n\n    // Lookup in current trie node.\n    var uCode = this.decodeTables[nodeIdx][curByte];\n    if (uCode >= 0) {\n      // Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n      i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n    } else if (uCode === GB18030_CODE) {\n      var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);\n      var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n    // Write the character to buffer, handling higher planes using surrogate pair.\n    if (uCode > 0xFFFF) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 + uCode % 0x400;\n    }\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8;\n\n    // Reset trie node.\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n  this.nodeIdx = nodeIdx;\n  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n  return newBuf.slice(0, j).toString('ucs2');\n};\nDBCSDecoder.prototype.end = function () {\n  var ret = '';\n\n  // Try to parse all remaining chars.\n  while (this.prevBuf.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var buf = this.prevBuf.slice(1);\n\n    // Parse remaining as usual.\n    this.prevBuf = Buffer.alloc(0);\n    this.nodeIdx = 0;\n    if (buf.length > 0) ret += this.write(buf);\n  }\n  this.nodeIdx = 0;\n  return ret;\n};\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n    r = table.length;\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + Math.floor((r - l + 1) / 2);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n  return l;\n}","map":{"version":3,"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","j","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","gb18030","thirdByteNodeIdx","thirdByteNode","fourthByteNodeIdx","fourthByteNode","secondByteNodeIdx","secondByteNode","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","push","node","toString","chunk","curAddr","parseInt","writeTable","k","part","l","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","mbCode","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBuf","buf","prevBufOffset","seqStart","concat","curByte","curSeq","ptr","uCodeLead","ret","r","mid"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-codec.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = Buffer.alloc(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = Buffer.alloc(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}