{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\n\nimport { h, s } from 'hastscript';\nimport { html, svg, find } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty;\n\n// Handlers.\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n};\n\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\nexport function fromParse5(ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  /** @type {Options} */\n  let settings;\n  /** @type {VFile|undefined} */\n  let file;\n  if (isFile(options)) {\n    file = options;\n    settings = {};\n  } else {\n    file = options.file;\n    settings = options;\n  }\n  return transform({\n    schema: settings.space === 'svg' ? svg : html,\n    file,\n    verbose: settings.verbose,\n    location: false\n  }, ast);\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\nfunction transform(ctx, ast) {\n  const schema = ctx.schema;\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element;\n  /** @type {Array.<Child>|undefined} */\n  let children;\n\n  // Element.\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html;\n  }\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes);\n  }\n  const result = fn(ctx, ast, children);\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation);\n    if (position) {\n      ctx.location = true;\n      result.position = position;\n    }\n  }\n  ctx.schema = schema;\n  return result;\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\nfunction nodes(ctx, children) {\n  let index = -1;\n  /** @type {Array.<Child>} */\n  const result = [];\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index]);\n  }\n  return result;\n}\n\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {\n      quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'\n    }\n  };\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file);\n    const loc = location(doc);\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    };\n  }\n  return result;\n}\n\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {\n    type: 'doctype'\n  };\n}\n\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\nfunction text(_, ast) {\n  return {\n    type: 'text',\n    value: ast.value\n  };\n}\n\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\nfunction comment(_, ast) {\n  return {\n    type: 'comment',\n    value: ast.data\n  };\n}\n\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h;\n  let index = -1;\n  /** @type {Object.<string, string>} */\n  const props = {};\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index];\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] = attribute.value;\n  }\n  const result = fn(ast.tagName, props, children);\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = transform(ctx, ast.content);\n    if (startTag && endTag && ctx.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n    result.content = content;\n  }\n  return result;\n}\n\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\nfunction createLocation(ctx, node, location) {\n  const result = position(location);\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1];\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {};\n      /** @type {string} */\n      let key;\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key]);\n        }\n      }\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n  // @ts-expect-error `null` is fine.\n  return start || end ? {\n    start,\n    end\n  } : null;\n}\n\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\nfunction point(point) {\n  return point.line && point.column ? point : null;\n}\n\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\nfunction isFile(value) {\n  return 'messages' in value;\n}","map":{"version":3,"names":["h","s","html","svg","find","location","webNamespaces","own","hasOwnProperty","map","root","text","comment","doctype","fromParse5","ast","options","settings","file","isFile","transform","schema","space","verbose","ctx","fn","call","nodeName","element","children","namespaceURI","nodes","childNodes","result","sourceCodeLocation","position","createLocation","index","length","type","data","quirksMode","mode","doc","String","loc","start","toPoint","end","_","value","props","attrs","attribute","prefix","name","tagName","pos","startTag","endTag","content","node","tail","Object","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n\n// Handlers.\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n}\n\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\nexport function fromParse5(ast, options = {}) {\n  /** @type {Options} */\n  let settings\n  /** @type {VFile|undefined} */\n  let file\n\n  if (isFile(options)) {\n    file = options\n    settings = {}\n  } else {\n    file = options.file\n    settings = options\n  }\n\n  return transform(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    ast\n  )\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\nfunction transform(ctx, ast) {\n  const schema = ctx.schema\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element\n  /** @type {Array.<Child>|undefined} */\n  let children\n\n  // Element.\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes)\n  }\n\n  const result = fn(ctx, ast, children)\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation)\n\n    if (position) {\n      ctx.location = true\n      result.position = position\n    }\n  }\n\n  ctx.schema = schema\n\n  return result\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\nfunction nodes(ctx, children) {\n  let index = -1\n  /** @type {Array.<Child>} */\n  const result = []\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index])\n  }\n\n  return result\n}\n\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'}\n  }\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file)\n    const loc = location(doc)\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\nfunction text(_, ast) {\n  return {type: 'text', value: ast.value}\n}\n\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\nfunction comment(_, ast) {\n  return {type: 'comment', value: ast.data}\n}\n\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h\n  let index = -1\n  /** @type {Object.<string, string>} */\n  const props = {}\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index]\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] =\n      attribute.value\n  }\n\n  const result = fn(ast.tagName, props, children)\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = transform(ctx, ast.content)\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  return result\n}\n\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\nfunction createLocation(ctx, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key])\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `null` is fine.\n  return start || end ? {start, end} : null\n}\n\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\nfunction point(point) {\n  return point.line && point.column ? point : null\n}\n\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}