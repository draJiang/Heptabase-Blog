{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n\n/** @type {Construct} */\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this;\n  /** @type {string} */\n  let identifier;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter(types.definition);\n    return factoryLabel.call(self, effects, labelAfter, nok, types.definitionLabel, types.definitionLabelMarker, types.definitionLabelString)(code);\n  }\n\n  /** @type {State} */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker);\n      effects.consume(code);\n      effects.exit(types.definitionMarker);\n\n      // Note: blank lines can’t exist in content.\n      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, types.whitespace), factorySpace(effects, after, types.whitespace)), nok, types.definitionDestination, types.definitionDestinationLiteral, types.definitionDestinationLiteralMarker, types.definitionDestinationRaw, types.definitionDestinationString));\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition);\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);\n  }\n\n  /** @type {State} */\n  function before(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, factorySpace(effects, after, types.whitespace), nok, types.definitionTitle, types.definitionTitleMarker, types.definitionTitleString)(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factoryDestination","factoryLabel","factorySpace","factoryTitle","factoryWhitespace","normalizeIdentifier","markdownLineEnding","markdownLineEndingOrSpace","codes","types","definition","name","tokenize","tokenizeDefinition","titleConstruct","tokenizeTitle","partial","effects","nok","self","identifier","start","code","leftSquareBracket","enter","call","labelAfter","definitionLabel","definitionLabelMarker","definitionLabelString","sliceSerialize","events","length","slice","colon","definitionMarker","consume","exit","attempt","after","whitespace","definitionDestination","definitionDestinationLiteral","definitionDestinationLiteralMarker","definitionDestinationRaw","definitionDestinationString","eof","parser","defined","includes","push","before","quotationMark","apostrophe","leftParenthesis","definitionTitle","definitionTitleMarker","definitionTitleString"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/definition.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const definition = {name: 'definition', tokenize: tokenizeDefinition}\n\n/** @type {Construct} */\nconst titleConstruct = {tokenize: tokenizeTitle, partial: true}\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n  let identifier\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter(types.definition)\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      types.definitionLabel,\n      types.definitionLabelMarker,\n      types.definitionLabelString\n    )(code)\n  }\n\n  /** @type {State} */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker)\n      effects.consume(code)\n      effects.exit(types.definitionMarker)\n\n      // Note: blank lines can’t exist in content.\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, types.whitespace),\n            factorySpace(effects, after, types.whitespace)\n          ),\n          nok,\n          types.definitionDestination,\n          types.definitionDestinationLiteral,\n          types.definitionDestinationLiteralMarker,\n          types.definitionDestinationRaw,\n          types.definitionDestinationString\n        )\n      )\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition)\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n\n  /** @type {State} */\n  function before(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, types.whitespace),\n        nok,\n        types.definitionTitle,\n        types.definitionTitleMarker,\n        types.definitionTitleString\n      )(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}