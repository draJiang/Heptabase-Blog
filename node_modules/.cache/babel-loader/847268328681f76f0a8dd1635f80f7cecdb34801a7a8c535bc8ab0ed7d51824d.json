{"ast":null,"code":"'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n  constructor(treeAdapter) {\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  }\n\n  //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n  _getNoahArkConditionCandidates(newElement) {\n    const candidates = [];\n    if (this.length >= NOAH_ARK_CAPACITY) {\n      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n      const neTagName = this.treeAdapter.getTagName(newElement);\n      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n      for (let i = this.length - 1; i >= 0; i--) {\n        const entry = this.entries[i];\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n        const element = entry.element;\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        const isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n        if (isCandidate) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n  }\n  _ensureNoahArkCondition(newElement) {\n    const candidates = this._getNoahArkConditionCandidates(newElement);\n    let cLength = candidates.length;\n    if (cLength) {\n      const neAttrs = this.treeAdapter.getAttrList(newElement);\n      const neAttrsLength = neAttrs.length;\n      const neAttrsMap = Object.create(null);\n\n      //NOTE: build attrs map for the new element so we can perform fast lookups\n      for (let i = 0; i < neAttrsLength; i++) {\n        const neAttr = neAttrs[i];\n        neAttrsMap[neAttr.name] = neAttr.value;\n      }\n      for (let i = 0; i < neAttrsLength; i++) {\n        for (let j = 0; j < cLength; j++) {\n          const cAttr = candidates[j].attrs[i];\n          if (neAttrsMap[cAttr.name] !== cAttr.value) {\n            candidates.splice(j, 1);\n            cLength--;\n          }\n          if (candidates.length < NOAH_ARK_CAPACITY) {\n            return;\n          }\n        }\n      }\n\n      //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n        this.entries.splice(candidates[i].idx, 1);\n        this.length--;\n      }\n    }\n  }\n\n  //Mutations\n  insertMarker() {\n    this.entries.push({\n      type: FormattingElementList.MARKER_ENTRY\n    });\n    this.length++;\n  }\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n    this.entries.push({\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n  insertElementAfterBookmark(element, token) {\n    let bookmarkIdx = this.length - 1;\n    for (; bookmarkIdx >= 0; bookmarkIdx--) {\n      if (this.entries[bookmarkIdx] === this.bookmark) {\n        break;\n      }\n    }\n    this.entries.splice(bookmarkIdx + 1, 0, {\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n  removeEntry(entry) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.entries[i] === entry) {\n        this.entries.splice(i, 1);\n        this.length--;\n        break;\n      }\n    }\n  }\n  clearToLastMarker() {\n    while (this.length) {\n      const entry = this.entries.pop();\n      this.length--;\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        break;\n      }\n    }\n  }\n\n  //Search\n  getElementEntryInScopeWithTagName(tagName) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        return null;\n      }\n      if (this.treeAdapter.getTagName(entry.element) === tagName) {\n        return entry;\n      }\n    }\n    return null;\n  }\n  getElementEntry(element) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n      if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n        return entry;\n      }\n    }\n    return null;\n  }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;","map":{"version":3,"names":["NOAH_ARK_CAPACITY","FormattingElementList","constructor","treeAdapter","length","entries","bookmark","_getNoahArkConditionCandidates","newElement","candidates","neAttrsLength","getAttrList","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","type","MARKER_ENTRY","element","elementAttrs","isCandidate","push","idx","attrs","_ensureNoahArkCondition","cLength","neAttrs","neAttrsMap","Object","create","neAttr","name","value","j","cAttr","splice","insertMarker","pushElement","token","ELEMENT_ENTRY","insertElementAfterBookmark","bookmarkIdx","removeEntry","clearToLastMarker","pop","getElementEntryInScopeWithTagName","tagName","getElementEntry","module","exports"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/parse5/lib/parser/formatting-element-list.js"],"sourcesContent":["'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}