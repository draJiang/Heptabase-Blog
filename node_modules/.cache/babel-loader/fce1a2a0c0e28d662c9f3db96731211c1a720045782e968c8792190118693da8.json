{"ast":null,"code":"/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar Route = require('./route');\nvar Layer = require('./layer');\nvar methods = require('methods');\nvar mixin = require('utils-merge');\nvar debug = require('debug')('express:router');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar parseUrl = require('parseurl');\nvar setPrototypeOf = require('setprototypeof');\n\n/**\n * Module variables.\n * @private\n */\n\nvar objectRegExp = /^\\[object (\\S+)\\]$/;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {Object} [options]\n * @return {Router} which is an callable function\n * @public\n */\n\nvar proto = module.exports = function (options) {\n  var opts = options || {};\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto);\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n  router.stack = [];\n  return router;\n};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code,\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  app.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err);\n *      } else if (!user) {\n *        return next(new Error('failed to load user'));\n *      }\n *      req.user = user;\n *      next();\n *    });\n *  });\n *\n * @param {String} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\nproto.param = function param(name, fn) {\n  // param logic\n  if (typeof name === 'function') {\n    deprecate('router.param(fn): Refactor to use path params');\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params;\n  var len = params.length;\n  var ret;\n  if (name[0] === ':') {\n    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead');\n    name = name.slice(1);\n  }\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' !== typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Dispatch a req, res into the router.\n * @private\n */\n\nproto.handle = function handle(req, res, out) {\n  var self = this;\n  debug('dispatching %s %s', req.method, req.url);\n  var idx = 0;\n  var protohost = getProtohost(req.url) || '';\n  var removed = '';\n  var slashAdded = false;\n  var sync = 0;\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function (old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n  next();\n  function next(err) {\n    var layerError = err === 'route' ? null : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.slice(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null);\n      return;\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err);\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n      if (match !== true) {\n        continue;\n      }\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err);\n      } else if (route) {\n        layer.handle_request(req, res, next);\n      } else {\n        trim_prefix(layer, layerError, layerPath, path);\n      }\n      sync = 0;\n    });\n  }\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError);\n        return;\n      }\n\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length];\n      if (c && c !== '/' && c !== '.') return next(layerError);\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.slice(protohost.length + removed.length);\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);\n    }\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Process any parameters for the layer.\n * @private\n */\n\nproto.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params;\n\n  // captured parameters from the layer, keys and values\n  var keys = layer.keys;\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled;\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n    if (i >= keys.length) {\n      return done();\n    }\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {\n      // restore value\n      req.params[name] = paramCalled.value;\n\n      // next param\n      return param(paramCalled.error);\n    }\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n    paramCallback();\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++];\n\n    // store updated value\n    paramCalled.value = req.params[key.name];\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n    if (!fn) return param();\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n  param();\n};\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n  var callbacks = flatten(slice.call(arguments, offset));\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function');\n  }\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn));\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>');\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n    layer.route = undefined;\n    this.stack.push(layer);\n  }\n  return this;\n};\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\n\nproto.route = function route(path) {\n  var route = new Route(path);\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n  layer.route = route;\n  this.stack.push(layer);\n  return route;\n};\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function (method) {\n  proto[method] = function (path) {\n    var route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n// append methods to a list of methods\nfunction appendMethods(list, addition) {\n  for (var i = 0; i < addition.length; i++) {\n    var method = addition[i];\n    if (list.indexOf(method) === -1) {\n      list.push(method);\n    }\n  }\n}\n\n// get pathname of request\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n\n// Get get protocol + host for a URL\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined;\n  }\n  var searchIndex = url.indexOf('?');\n  var pathLength = searchIndex !== -1 ? searchIndex : url.length;\n  var fqdnIndex = url.slice(0, pathLength).indexOf('://');\n  return fqdnIndex !== -1 ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;\n}\n\n// get type for error message\nfunction gettype(obj) {\n  var type = typeof obj;\n  if (type !== 'object') {\n    return type;\n  }\n\n  // inspect [[Class]] for objects\n  return toString.call(obj).replace(objectRegExp, '$1');\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n\n// merge params with parent params\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n\n  // make copy of parent for base\n  var obj = mixin({}, parent);\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params);\n  }\n  var i = 0;\n  var o = 0;\n\n  // determine numeric gaps\n  while (i in params) {\n    i++;\n  }\n  while (o in parent) {\n    o++;\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i];\n    }\n  }\n  return mixin(obj, params);\n}\n\n// restore obj props after function\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n  return function () {\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n    return fn.apply(this, arguments);\n  };\n}\n\n// send an OPTIONS response\nfunction sendOptionsResponse(res, options, next) {\n  try {\n    var body = options.join(',');\n    res.set('Allow', body);\n    res.send(body);\n  } catch (err) {\n    next(err);\n  }\n}\n\n// wrap a function\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n    args[0] = old;\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n    fn.apply(this, args);\n  };\n}","map":{"version":3,"names":["Route","require","Layer","methods","mixin","debug","deprecate","flatten","parseUrl","setPrototypeOf","objectRegExp","slice","Array","prototype","toString","Object","proto","module","exports","options","opts","router","req","res","next","handle","params","_params","caseSensitive","mergeParams","strict","stack","param","name","fn","push","len","length","ret","JSON","stringify","i","Error","out","self","method","url","idx","protohost","getProtohost","removed","slashAdded","sync","paramcalled","parentParams","parentUrl","baseUrl","done","restore","wrap","old","err","sendOptionsResponse","originalUrl","layerError","setImmediate","path","getPathname","layer","match","route","matchLayer","has_method","_handles_method","appendMethods","_options","layerPath","process_params","handle_request","trim_prefix","c","substring","handle_error","called","keys","paramIndex","key","paramVal","paramCallbacks","paramCalled","undefined","error","value","paramCallback","e","use","offset","arg","isArray","callbacks","call","arguments","TypeError","gettype","sensitive","end","dispatch","bind","concat","forEach","apply","list","addition","indexOf","pathname","searchIndex","pathLength","fqdnIndex","obj","type","replace","parent","o","props","vals","body","join","set","send","proxy","args"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/express/lib/router/index.js"],"sourcesContent":["/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Route = require('./route');\nvar Layer = require('./layer');\nvar methods = require('methods');\nvar mixin = require('utils-merge');\nvar debug = require('debug')('express:router');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar parseUrl = require('parseurl');\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Module variables.\n * @private\n */\n\nvar objectRegExp = /^\\[object (\\S+)\\]$/;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {Object} [options]\n * @return {Router} which is an callable function\n * @public\n */\n\nvar proto = module.exports = function(options) {\n  var opts = options || {};\n\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto)\n\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n  router.stack = [];\n\n  return router;\n};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code,\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  app.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err);\n *      } else if (!user) {\n *        return next(new Error('failed to load user'));\n *      }\n *      req.user = user;\n *      next();\n *    });\n *  });\n *\n * @param {String} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\nproto.param = function param(name, fn) {\n  // param logic\n  if (typeof name === 'function') {\n    deprecate('router.param(fn): Refactor to use path params');\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params;\n  var len = params.length;\n  var ret;\n\n  if (name[0] === ':') {\n    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead')\n    name = name.slice(1)\n  }\n\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' !== typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Dispatch a req, res into the router.\n * @private\n */\n\nproto.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug('dispatching %s %s', req.method, req.url);\n\n  var idx = 0;\n  var protohost = getProtohost(req.url) || ''\n  var removed = '';\n  var slashAdded = false;\n  var sync = 0\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1)\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.slice(protohost.length)\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err)\n      } else if (route) {\n        layer.handle_request(req, res, next)\n      } else {\n        trim_prefix(layer, layerError, layerPath, path)\n      }\n\n      sync = 0\n    });\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Process any parameters for the layer.\n * @private\n */\n\nproto.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params;\n\n  // captured parameters from the layer, keys and values\n  var keys = layer.keys;\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled;\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n\n    if (i >= keys.length ) {\n      return done();\n    }\n\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal\n      || (paramCalled.error && paramCalled.error !== 'route'))) {\n      // restore value\n      req.params[name] = paramCalled.value;\n\n      // next param\n      return param(paramCalled.error);\n    }\n\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n\n    paramCallback();\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++];\n\n    // store updated value\n    paramCalled.value = req.params[key.name];\n\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n\n    if (!fn) return param();\n\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n\n  param();\n};\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\n\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function(method){\n  proto[method] = function(path){\n    var route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n// append methods to a list of methods\nfunction appendMethods(list, addition) {\n  for (var i = 0; i < addition.length; i++) {\n    var method = addition[i];\n    if (list.indexOf(method) === -1) {\n      list.push(method);\n    }\n  }\n}\n\n// get pathname of request\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n\n// Get get protocol + host for a URL\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined\n  }\n\n  var searchIndex = url.indexOf('?')\n  var pathLength = searchIndex !== -1\n    ? searchIndex\n    : url.length\n  var fqdnIndex = url.slice(0, pathLength).indexOf('://')\n\n  return fqdnIndex !== -1\n    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))\n    : undefined\n}\n\n// get type for error message\nfunction gettype(obj) {\n  var type = typeof obj;\n\n  if (type !== 'object') {\n    return type;\n  }\n\n  // inspect [[Class]] for objects\n  return toString.call(obj)\n    .replace(objectRegExp, '$1');\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n\n// merge params with parent params\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n\n  // make copy of parent for base\n  var obj = mixin({}, parent);\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params);\n  }\n\n  var i = 0;\n  var o = 0;\n\n  // determine numeric gaps\n  while (i in params) {\n    i++;\n  }\n\n  while (o in parent) {\n    o++;\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i];\n    }\n  }\n\n  return mixin(obj, params);\n}\n\n// restore obj props after function\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n\n  return function () {\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n\n// send an OPTIONS response\nfunction sendOptionsResponse(res, options, next) {\n  try {\n    var body = options.join(',');\n    res.set('Allow', body);\n    res.send(body);\n  } catch (err) {\n    next(err);\n  }\n}\n\n// wrap a function\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n\n    args[0] = old;\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n\n    fn.apply(this, args);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}