{"ast":null,"code":"/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar typer = require('media-typer');\nvar mime = require('mime-types');\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest;\nmodule.exports.is = typeis;\nmodule.exports.hasBody = hasbody;\nmodule.exports.normalize = normalize;\nmodule.exports.match = mimeMatch;\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis(value, types_) {\n  var i;\n  var types = types_;\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value);\n\n  // no type or invalid\n  if (!val) {\n    return false;\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1);\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val;\n  }\n  var type;\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;\n    }\n  }\n\n  // no matches\n  return false;\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody(req) {\n  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest(req, types_) {\n  var types = types_;\n\n  // no body\n  if (!hasbody(req)) {\n    return null;\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1);\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type'];\n  return typeis(value, types);\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize(type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false;\n  }\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n    case 'multipart':\n      return 'multipart/*';\n  }\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type;\n  }\n  return type.indexOf('/') === -1 ? mime.lookup(type) : type;\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch(expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false;\n  }\n\n  // split types\n  var actualParts = actual.split('/');\n  var expectedParts = expected.split('/');\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false;\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false;\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType(value) {\n  // parse the type\n  var type = typer.parse(value);\n\n  // remove the parameters\n  type.parameters = undefined;\n\n  // reformat it\n  return typer.format(type);\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType(value) {\n  if (!value) {\n    return null;\n  }\n  try {\n    return normalizeType(value);\n  } catch (err) {\n    return null;\n  }\n}","map":{"version":3,"names":["typer","require","mime","module","exports","typeofrequest","is","typeis","hasBody","hasbody","normalize","match","mimeMatch","value","types_","i","types","val","tryNormalizeType","Array","isArray","arguments","length","type","indexOf","req","headers","undefined","isNaN","lookup","expected","actual","actualParts","split","expectedParts","substr","normalizeType","parse","parameters","format","err"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/type-is/index.js"],"sourcesContent":["/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest\nmodule.exports.is = typeis\nmodule.exports.hasBody = hasbody\nmodule.exports.normalize = normalize\nmodule.exports.match = mimeMatch\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis (value, types_) {\n  var i\n  var types = types_\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) {\n    return false\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1)\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val\n  }\n\n  var type\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1\n        ? val\n        : type\n    }\n  }\n\n  // no matches\n  return false\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest (req, types_) {\n  var types = types_\n\n  // no body\n  if (!hasbody(req)) {\n    return null\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type']\n\n  return typeis(value, types)\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize (type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type\n  }\n\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch (expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false\n  }\n\n  // split types\n  var actualParts = actual.split('/')\n  var expectedParts = expected.split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType (value) {\n  // parse the type\n  var type = typer.parse(value)\n\n  // remove the parameters\n  type.parameters = undefined\n\n  // reformat it\n  return typer.format(type)\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType (value) {\n  if (!value) {\n    return null\n  }\n\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}