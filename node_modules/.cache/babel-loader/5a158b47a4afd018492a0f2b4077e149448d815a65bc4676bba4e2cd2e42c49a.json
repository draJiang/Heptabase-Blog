{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length;\n  /** @type {number|undefined} */\n  let content;\n  /** @type {number|undefined} */\n  let text;\n  /** @type {number|undefined} */\n  let definition;\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === types.content) {\n        content = index;\n        break;\n      }\n      if (events[index][1].type === types.paragraph) {\n        text = index;\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === types.content) {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n      if (!definition && events[index][1].type === types.definition) {\n        definition = index;\n      }\n    }\n  }\n  assert(text !== undefined, 'expected a `text` index to be found');\n  assert(content !== undefined, 'expected a `text` index to be found');\n  const heading = {\n    type: types.setextHeading,\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = types.setextHeadingText;\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context]);\n  return events;\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  /** @type {boolean} */\n  let paragraph;\n\n  // Find an opening.\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== types.lineEnding && self.events[index][1].type !== types.linePrefix && self.events[index][1].type !== types.content) {\n      paragraph = self.events[index][1].type === types.paragraph;\n      break;\n    }\n  }\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.dash || code === codes.equalsTo, 'expected `=` or `-`');\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine);\n      effects.enter(types.setextHeadingLineSequence);\n      marker = code;\n      return closingSequence(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return closingSequence;\n    }\n    effects.exit(types.setextHeadingLineSequence);\n    return factorySpace(effects, closingSequenceEnd, types.lineSuffix)(code);\n  }\n\n  /** @type {State} */\n  function closingSequenceEnd(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine);\n      return ok(code);\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","codes","types","setextUnderline","name","tokenize","tokenizeSetextUnderline","resolveTo","resolveToSetextUnderline","events","context","index","length","content","text","definition","type","paragraph","splice","undefined","heading","setextHeading","start","Object","assign","end","setextHeadingText","push","effects","nok","self","marker","lineEnding","linePrefix","code","dash","equalsTo","parser","lazy","now","line","interrupt","enter","setextHeadingLine","setextHeadingLineSequence","closingSequence","consume","exit","closingSequenceEnd","lineSuffix","eof"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n  let content\n  /** @type {number|undefined} */\n  let text\n  /** @type {number|undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === types.content) {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === types.paragraph) {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === types.content) {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === types.definition) {\n        definition = index\n      }\n    }\n  }\n\n  assert(text !== undefined, 'expected a `text` index to be found')\n  assert(content !== undefined, 'expected a `text` index to be found')\n\n  const heading = {\n    type: types.setextHeading,\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = types.setextHeadingText\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n  let marker\n  /** @type {boolean} */\n  let paragraph\n\n  // Find an opening.\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== types.lineEnding &&\n      self.events[index][1].type !== types.linePrefix &&\n      self.events[index][1].type !== types.content\n    ) {\n      paragraph = self.events[index][1].type === types.paragraph\n      break\n    }\n  }\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(\n      code === codes.dash || code === codes.equalsTo,\n      'expected `=` or `-`'\n    )\n\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine)\n      effects.enter(types.setextHeadingLineSequence)\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit(types.setextHeadingLineSequence)\n    return factorySpace(effects, closingSequenceEnd, types.lineSuffix)(code)\n  }\n\n  /** @type {State} */\n  function closingSequenceEnd(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine)\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}