{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n  let content;\n  /** @type {Token} */\n  let text;\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2;\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {\n    contentEnd -= 2;\n  }\n  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: constants.contentTypeText\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n  return events;\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.numberSign, 'expected `#`');\n    effects.enter(types.atxHeading);\n    effects.enter(types.atxHeadingSequence);\n    return fenceOpenInside(code);\n  }\n\n  /** @type {State} */\n  function fenceOpenInside(code) {\n    if (code === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {\n      effects.consume(code);\n      return fenceOpenInside;\n    }\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence);\n      return self.interrupt ? ok(code) : headingBreak(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function headingBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence);\n      return sequence(code);\n    }\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading);\n      return ok(code);\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, types.whitespace)(code);\n    }\n    effects.enter(types.atxHeadingText);\n    return data(code);\n  }\n\n  /** @type {State} */\n  function sequence(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code);\n      return sequence;\n    }\n    effects.exit(types.atxHeadingSequence);\n    return headingBreak(code);\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (code === codes.eof || code === codes.numberSign || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingText);\n      return headingBreak(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","splice","codes","constants","types","headingAtx","name","tokenize","tokenizeHeadingAtx","resolve","resolveHeadingAtx","events","context","contentEnd","length","contentStart","content","text","type","whitespace","atxHeadingSequence","atxHeadingText","start","end","chunkText","contentType","contentTypeText","effects","nok","self","size","code","numberSign","enter","atxHeading","fenceOpenInside","atxHeadingOpeningFenceSizeMax","consume","eof","exit","interrupt","headingBreak","sequence","data"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === types.whitespace\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === types.atxHeadingSequence &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === types.whitespace))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: constants.contentTypeText\n    }\n\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.numberSign, 'expected `#`')\n    effects.enter(types.atxHeading)\n    effects.enter(types.atxHeadingSequence)\n    return fenceOpenInside(code)\n  }\n\n  /** @type {State} */\n  function fenceOpenInside(code) {\n    if (\n      code === codes.numberSign &&\n      size++ < constants.atxHeadingOpeningFenceSizeMax\n    ) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence)\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function headingBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence)\n      return sequence(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading)\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, types.whitespace)(code)\n    }\n\n    effects.enter(types.atxHeadingText)\n    return data(code)\n  }\n\n  /** @type {State} */\n  function sequence(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit(types.atxHeadingSequence)\n    return headingBreak(code)\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (\n      code === codes.eof ||\n      code === codes.numberSign ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit(types.atxHeadingText)\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}