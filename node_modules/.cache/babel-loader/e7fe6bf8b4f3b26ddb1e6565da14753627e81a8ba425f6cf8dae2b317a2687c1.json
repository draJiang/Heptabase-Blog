{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n\n/** @type {Tokenizer} */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  const tail = this.events[this.events.length - 1];\n  const initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.graveAccent || code === codes.tilde, 'expected `` ` `` or `~`');\n    effects.enter(types.codeFenced);\n    effects.enter(types.codeFencedFence);\n    effects.enter(types.codeFencedFenceSequence);\n    marker = code;\n    return sequenceOpen(code);\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit(types.codeFencedFenceSequence);\n    return sizeOpen < constants.codeFencedSequenceSizeMin ? nok(code) : factorySpace(effects, infoOpen, types.whitespace)(code);\n  }\n\n  /** @type {State} */\n  function infoOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n    effects.enter(types.codeFencedFenceInfo);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return info(code);\n  }\n\n  /** @type {State} */\n  function info(code) {\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return factorySpace(effects, infoAfter, types.whitespace)(code);\n    }\n    if (code === codes.graveAccent && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n\n  /** @type {State} */\n  function infoAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n    effects.enter(types.codeFencedFenceMeta);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceMeta);\n      return openAfter(code);\n    }\n    if (code === codes.graveAccent && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit(types.codeFencedFence);\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, types.linePrefix, initialPrefix + 1) : contentStart), after)(code);\n    }\n    effects.enter(types.codeFlowValue);\n    return contentContinue(code);\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue);\n      return contentStart(code);\n    }\n    effects.consume(code);\n    return contentContinue;\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit(types.codeFenced);\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return lineStart;\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingSequenceStart, types.linePrefix, this.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n\n    /** @type {State} */\n    function closingSequenceStart(code) {\n      effects.enter(types.codeFencedFence);\n      effects.enter(types.codeFencedFenceSequence);\n      return closingSequence(code);\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n      if (size < sizeOpen) return nok(code);\n      effects.exit(types.codeFencedFenceSequence);\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code);\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence);\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","codes","constants","types","codeFenced","name","tokenize","tokenizeCodeFenced","concrete","effects","nok","self","closingFenceConstruct","tokenizeClosingFence","partial","nonLazyLine","tokenizeNonLazyLine","tail","events","length","initialPrefix","type","linePrefix","sliceSerialize","sizeOpen","marker","start","code","graveAccent","tilde","enter","codeFencedFence","codeFencedFenceSequence","sequenceOpen","consume","exit","codeFencedSequenceSizeMin","infoOpen","whitespace","eof","openAfter","codeFencedFenceInfo","chunkString","contentType","contentTypeString","info","infoAfter","codeFencedFenceMeta","meta","interrupt","contentStart","after","attempt","codeFlowValue","contentContinue","lineEnding","lineStart","parser","lazy","now","line","size","closingSequenceStart","constructs","disable","null","includes","undefined","tabSize","closingSequence","closingSequenceEnd"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/micromark-core-commonmark/dev/lib/code-fenced.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closingFenceConstruct = {tokenize: tokenizeClosingFence, partial: true}\n  /** @type {Construct} */\n  const nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(\n      code === codes.graveAccent || code === codes.tilde,\n      'expected `` ` `` or `~`'\n    )\n    effects.enter(types.codeFenced)\n    effects.enter(types.codeFencedFence)\n    effects.enter(types.codeFencedFenceSequence)\n    marker = code\n    return sequenceOpen(code)\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit(types.codeFencedFenceSequence)\n    return sizeOpen < constants.codeFencedSequenceSizeMin\n      ? nok(code)\n      : factorySpace(effects, infoOpen, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function infoOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter(types.codeFencedFenceInfo)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return info(code)\n  }\n\n  /** @type {State} */\n  function info(code) {\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return factorySpace(effects, infoAfter, types.whitespace)(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n\n  /** @type {State} */\n  function infoAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter(types.codeFencedFenceMeta)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceMeta)\n      return openAfter(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit(types.codeFencedFence)\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                types.linePrefix,\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter(types.codeFlowValue)\n    return contentContinue(code)\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue)\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit(types.codeFenced)\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return lineStart\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      types.linePrefix,\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )\n\n    /** @type {State} */\n    function closingSequenceStart(code) {\n      effects.enter(types.codeFencedFence)\n      effects.enter(types.codeFencedFenceSequence)\n      return closingSequence(code)\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit(types.codeFencedFenceSequence)\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}