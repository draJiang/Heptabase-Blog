{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\nvar bytes = require('bytes');\nvar debug = require('debug')('body-parser:raw');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw;\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw(options) {\n  var opts = options || {};\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/octet-stream';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(buf) {\n    return buf;\n  }\n  return function rawParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","debug","read","typeis","module","exports","raw","options","opts","inflate","limit","parse","type","verify","TypeError","shouldParse","typeChecker","buf","rawParser","req","res","next","_body","body","hasBody","headers","encoding","checkType","Boolean"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/body-parser/lib/types/raw.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw (options) {\n  var opts = options || {}\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function rawParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,iBAAiB,CAAC;AAC/C,IAAIE,IAAI,GAAGF,OAAO,CAAC,SAAS,CAAC;AAC7B,IAAIG,MAAM,GAAGH,OAAO,CAAC,SAAS,CAAC;;AAE/B;AACA;AACA;;AAEAI,MAAM,CAACC,OAAO,GAAGC,GAAG;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,GAAG,CAAEC,OAAO,EAAE;EACrB,IAAIC,IAAI,GAAGD,OAAO,IAAI,CAAC,CAAC;EAExB,IAAIE,OAAO,GAAGD,IAAI,CAACC,OAAO,KAAK,KAAK;EACpC,IAAIC,KAAK,GAAG,OAAOF,IAAI,CAACE,KAAK,KAAK,QAAQ,GACtCX,KAAK,CAACY,KAAK,CAACH,IAAI,CAACE,KAAK,IAAI,OAAO,CAAC,GAClCF,IAAI,CAACE,KAAK;EACd,IAAIE,IAAI,GAAGJ,IAAI,CAACI,IAAI,IAAI,0BAA0B;EAClD,IAAIC,MAAM,GAAGL,IAAI,CAACK,MAAM,IAAI,KAAK;EAEjC,IAAIA,MAAM,KAAK,KAAK,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IACpD,MAAM,IAAIC,SAAS,CAAC,gCAAgC,CAAC;EACvD;;EAEA;EACA,IAAIC,WAAW,GAAG,OAAOH,IAAI,KAAK,UAAU,GACxCI,WAAW,CAACJ,IAAI,CAAC,GACjBA,IAAI;EAER,SAASD,KAAK,CAAEM,GAAG,EAAE;IACnB,OAAOA,GAAG;EACZ;EAEA,OAAO,SAASC,SAAS,CAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAE;IACzC,IAAIF,GAAG,CAACG,KAAK,EAAE;MACbrB,KAAK,CAAC,qBAAqB,CAAC;MAC5BoB,IAAI,EAAE;MACN;IACF;IAEAF,GAAG,CAACI,IAAI,GAAGJ,GAAG,CAACI,IAAI,IAAI,CAAC,CAAC;;IAEzB;IACA,IAAI,CAACpB,MAAM,CAACqB,OAAO,CAACL,GAAG,CAAC,EAAE;MACxBlB,KAAK,CAAC,iBAAiB,CAAC;MACxBoB,IAAI,EAAE;MACN;IACF;IAEApB,KAAK,CAAC,iBAAiB,EAAEkB,GAAG,CAACM,OAAO,CAAC,cAAc,CAAC,CAAC;;IAErD;IACA,IAAI,CAACV,WAAW,CAACI,GAAG,CAAC,EAAE;MACrBlB,KAAK,CAAC,cAAc,CAAC;MACrBoB,IAAI,EAAE;MACN;IACF;;IAEA;IACAnB,IAAI,CAACiB,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEV,KAAK,EAAEV,KAAK,EAAE;MACjCyB,QAAQ,EAAE,IAAI;MACdjB,OAAO,EAAEA,OAAO;MAChBC,KAAK,EAAEA,KAAK;MACZG,MAAM,EAAEA;IACV,CAAC,CAAC;EACJ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASG,WAAW,CAAEJ,IAAI,EAAE;EAC1B,OAAO,SAASe,SAAS,CAAER,GAAG,EAAE;IAC9B,OAAOS,OAAO,CAACzB,MAAM,CAACgB,GAAG,EAAEP,IAAI,CAAC,CAAC;EACnC,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}