{"ast":null,"code":"/**\n * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode\n * @typedef {import('./index.js').H} H\n * @typedef {import('./index.js').Handler} Handler\n * @typedef {import('./index.js').Content} Content\n */\n\nimport { u } from 'unist-builder';\nconst own = {}.hasOwnProperty;\n\n/**\n * Transform an unknown node.\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction unknown(h, node) {\n  const data = node.data || {};\n  if ('value' in node && !(own.call(data, 'hName') || own.call(data, 'hProperties') || own.call(data, 'hChildren'))) {\n    return h.augment(node, u('text', node.value));\n  }\n  return h(node, 'div', all(h, node));\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nexport function one(h, node, parent) {\n  const type = node && node.type;\n  /** @type {Handler} */\n  let fn;\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n  if (own.call(h.handlers, type)) {\n    fn = h.handlers[type];\n  } else if (h.passThrough && h.passThrough.includes(type)) {\n    fn = returnNode;\n  } else {\n    fn = h.unknownHandler;\n  }\n  return (typeof fn === 'function' ? fn : unknown)(h, node, parent);\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction returnNode(h, node) {\n  // @ts-expect-error: Pass through custom node.\n  return 'children' in node ? {\n    ...node,\n    children: all(h, node)\n  } : node;\n}\n\n/**\n * @param {H} h\n * @param {MdastNode} parent\n */\nexport function all(h, parent) {\n  /** @type {Array<Content>} */\n  const values = [];\n  if ('children' in parent) {\n    const nodes = parent.children;\n    let index = -1;\n    while (++index < nodes.length) {\n      const result = one(h, nodes[index], parent);\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '');\n          }\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0];\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '');\n            }\n          }\n        }\n        if (Array.isArray(result)) {\n          values.push(...result);\n        } else {\n          values.push(result);\n        }\n      }\n    }\n  }\n  return values;\n}","map":{"version":3,"names":["u","own","hasOwnProperty","unknown","h","node","data","call","augment","value","all","one","parent","type","fn","Error","handlers","passThrough","includes","returnNode","unknownHandler","children","values","nodes","index","length","result","Array","isArray","replace","head","push"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/mdast-util-to-hast/lib/traverse.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode\n * @typedef {import('./index.js').H} H\n * @typedef {import('./index.js').Handler} Handler\n * @typedef {import('./index.js').Content} Content\n */\n\nimport {u} from 'unist-builder'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Transform an unknown node.\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction unknown(h, node) {\n  const data = node.data || {}\n\n  if (\n    'value' in node &&\n    !(\n      own.call(data, 'hName') ||\n      own.call(data, 'hProperties') ||\n      own.call(data, 'hChildren')\n    )\n  ) {\n    return h.augment(node, u('text', node.value))\n  }\n\n  return h(node, 'div', all(h, node))\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nexport function one(h, node, parent) {\n  const type = node && node.type\n  /** @type {Handler} */\n  let fn\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(h.handlers, type)) {\n    fn = h.handlers[type]\n  } else if (h.passThrough && h.passThrough.includes(type)) {\n    fn = returnNode\n  } else {\n    fn = h.unknownHandler\n  }\n\n  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)\n}\n\n/**\n * @type {Handler}\n * @param {MdastNode} node\n */\nfunction returnNode(h, node) {\n  // @ts-expect-error: Pass through custom node.\n  return 'children' in node ? {...node, children: all(h, node)} : node\n}\n\n/**\n * @param {H} h\n * @param {MdastNode} parent\n */\nexport function all(h, parent) {\n  /** @type {Array<Content>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n\n    while (++index < nodes.length) {\n      const result = one(h, nodes[index], parent)\n\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,CAAC,QAAO,eAAe;AAE/B,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA,SAASC,OAAO,CAACC,CAAC,EAAEC,IAAI,EAAE;EACxB,MAAMC,IAAI,GAAGD,IAAI,CAACC,IAAI,IAAI,CAAC,CAAC;EAE5B,IACE,OAAO,IAAID,IAAI,IACf,EACEJ,GAAG,CAACM,IAAI,CAACD,IAAI,EAAE,OAAO,CAAC,IACvBL,GAAG,CAACM,IAAI,CAACD,IAAI,EAAE,aAAa,CAAC,IAC7BL,GAAG,CAACM,IAAI,CAACD,IAAI,EAAE,WAAW,CAAC,CAC5B,EACD;IACA,OAAOF,CAAC,CAACI,OAAO,CAACH,IAAI,EAAEL,CAAC,CAAC,MAAM,EAAEK,IAAI,CAACI,KAAK,CAAC,CAAC;EAC/C;EAEA,OAAOL,CAAC,CAACC,IAAI,EAAE,KAAK,EAAEK,GAAG,CAACN,CAAC,EAAEC,IAAI,CAAC,CAAC;AACrC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASM,GAAG,CAACP,CAAC,EAAEC,IAAI,EAAEO,MAAM,EAAE;EACnC,MAAMC,IAAI,GAAGR,IAAI,IAAIA,IAAI,CAACQ,IAAI;EAC9B;EACA,IAAIC,EAAE;;EAEN;EACA,IAAI,CAACD,IAAI,EAAE;IACT,MAAM,IAAIE,KAAK,CAAC,sBAAsB,GAAGV,IAAI,GAAG,GAAG,CAAC;EACtD;EAEA,IAAIJ,GAAG,CAACM,IAAI,CAACH,CAAC,CAACY,QAAQ,EAAEH,IAAI,CAAC,EAAE;IAC9BC,EAAE,GAAGV,CAAC,CAACY,QAAQ,CAACH,IAAI,CAAC;EACvB,CAAC,MAAM,IAAIT,CAAC,CAACa,WAAW,IAAIb,CAAC,CAACa,WAAW,CAACC,QAAQ,CAACL,IAAI,CAAC,EAAE;IACxDC,EAAE,GAAGK,UAAU;EACjB,CAAC,MAAM;IACLL,EAAE,GAAGV,CAAC,CAACgB,cAAc;EACvB;EAEA,OAAO,CAAC,OAAON,EAAE,KAAK,UAAU,GAAGA,EAAE,GAAGX,OAAO,EAAEC,CAAC,EAAEC,IAAI,EAAEO,MAAM,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA,SAASO,UAAU,CAACf,CAAC,EAAEC,IAAI,EAAE;EAC3B;EACA,OAAO,UAAU,IAAIA,IAAI,GAAG;IAAC,GAAGA,IAAI;IAAEgB,QAAQ,EAAEX,GAAG,CAACN,CAAC,EAAEC,IAAI;EAAC,CAAC,GAAGA,IAAI;AACtE;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASK,GAAG,CAACN,CAAC,EAAEQ,MAAM,EAAE;EAC7B;EACA,MAAMU,MAAM,GAAG,EAAE;EAEjB,IAAI,UAAU,IAAIV,MAAM,EAAE;IACxB,MAAMW,KAAK,GAAGX,MAAM,CAACS,QAAQ;IAC7B,IAAIG,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO,EAAEA,KAAK,GAAGD,KAAK,CAACE,MAAM,EAAE;MAC7B,MAAMC,MAAM,GAAGf,GAAG,CAACP,CAAC,EAAEmB,KAAK,CAACC,KAAK,CAAC,EAAEZ,MAAM,CAAC;MAE3C,IAAIc,MAAM,EAAE;QACV,IAAIF,KAAK,IAAID,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC,CAACX,IAAI,KAAK,OAAO,EAAE;UAC9C,IAAI,CAACc,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAIA,MAAM,CAACb,IAAI,KAAK,MAAM,EAAE;YACpDa,MAAM,CAACjB,KAAK,GAAGiB,MAAM,CAACjB,KAAK,CAACoB,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;UACjD;UAEA,IAAI,CAACF,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAIA,MAAM,CAACb,IAAI,KAAK,SAAS,EAAE;YACvD,MAAMiB,IAAI,GAAGJ,MAAM,CAACL,QAAQ,CAAC,CAAC,CAAC;YAE/B,IAAIS,IAAI,IAAIA,IAAI,CAACjB,IAAI,KAAK,MAAM,EAAE;cAChCiB,IAAI,CAACrB,KAAK,GAAGqB,IAAI,CAACrB,KAAK,CAACoB,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;YAC7C;UACF;QACF;QAEA,IAAIF,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;UACzBJ,MAAM,CAACS,IAAI,CAAC,GAAGL,MAAM,CAAC;QACxB,CAAC,MAAM;UACLJ,MAAM,CAACS,IAAI,CAACL,MAAM,CAAC;QACrB;MACF;IACF;EACF;EAEA,OAAOJ,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}