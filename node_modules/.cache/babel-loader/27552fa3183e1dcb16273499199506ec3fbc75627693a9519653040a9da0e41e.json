{"ast":null,"code":"/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar asyncHooks = tryRequireAsyncHooks();\nvar bytes = require('bytes');\nvar createError = require('http-errors');\nvar iconv = require('iconv-lite');\nvar unpipe = require('unpipe');\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody;\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder(encoding) {\n  if (!encoding) return null;\n  try {\n    return iconv.getDecoder(encoding);\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody(stream, options, callback) {\n  var done = callback;\n  var opts = options || {};\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    };\n  }\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required');\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit);\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, wrap(done));\n  }\n  return new Promise(function executor(resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err);\n      resolve(buf);\n    });\n  });\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt(stream) {\n  // unpipe everything from the stream\n  unpipe(stream);\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause();\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream(stream, encoding, length, limit, callback) {\n  var complete = false;\n  var sync = true;\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }));\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState;\n  if (stream._decoder || state && (state.encoding || state.decoder)) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }));\n  }\n  if (typeof stream.readable !== 'undefined' && !stream.readable) {\n    return done(createError(500, 'stream is not readable', {\n      type: 'stream.not.readable'\n    }));\n  }\n  var received = 0;\n  var decoder;\n  try {\n    decoder = getDecoder(encoding);\n  } catch (err) {\n    return done(err);\n  }\n  var buffer = decoder ? '' : [];\n\n  // attach listeners\n  stream.on('aborted', onAborted);\n  stream.on('close', cleanup);\n  stream.on('data', onData);\n  stream.on('end', onEnd);\n  stream.on('error', onEnd);\n\n  // mark sync section complete\n  sync = false;\n  function done() {\n    var args = new Array(arguments.length);\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    // mark complete\n    complete = true;\n    if (sync) {\n      process.nextTick(invokeCallback);\n    } else {\n      invokeCallback();\n    }\n    function invokeCallback() {\n      cleanup();\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream);\n      }\n      callback.apply(null, args);\n    }\n  }\n  function onAborted() {\n    if (complete) return;\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }));\n  }\n  function onData(chunk) {\n    if (complete) return;\n    received += chunk.length;\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }));\n    } else if (decoder) {\n      buffer += decoder.write(chunk);\n    } else {\n      buffer.push(chunk);\n    }\n  }\n  function onEnd(err) {\n    if (complete) return;\n    if (err) return done(err);\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }));\n    } else {\n      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);\n      done(null, string);\n    }\n  }\n  function cleanup() {\n    buffer = null;\n    stream.removeListener('aborted', onAborted);\n    stream.removeListener('data', onData);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('error', onEnd);\n    stream.removeListener('close', cleanup);\n  }\n}\n\n/**\n * Try to require async_hooks\n * @private\n */\n\nfunction tryRequireAsyncHooks() {\n  try {\n    return require('async_hooks');\n  } catch (e) {\n    return {};\n  }\n}\n\n/**\n * Wrap function with async resource, if possible.\n * AsyncResource.bind static method backported.\n * @private\n */\n\nfunction wrap(fn) {\n  var res;\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn;\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null);\n}","map":{"version":3,"names":["asyncHooks","tryRequireAsyncHooks","bytes","require","createError","iconv","unpipe","module","exports","getRawBody","ICONV_ENCODING_MESSAGE_REGEXP","getDecoder","encoding","e","test","message","type","stream","options","callback","done","opts","undefined","TypeError","global","Promise","limit","parse","length","isNaN","parseInt","readStream","wrap","executor","resolve","reject","onRead","err","buf","halt","pause","complete","sync","expected","state","_readableState","_decoder","decoder","readable","received","buffer","on","onAborted","cleanup","onData","onEnd","args","Array","arguments","i","process","nextTick","invokeCallback","apply","code","chunk","write","push","string","end","Buffer","concat","removeListener","fn","res","AsyncResource","name","runInAsyncScope","bind"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/raw-body/index.js"],"sourcesContent":["/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar asyncHooks = tryRequireAsyncHooks()\nvar bytes = require('bytes')\nvar createError = require('http-errors')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, wrap(done))\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  if (typeof stream.readable !== 'undefined' && !stream.readable) {\n    return done(createError(500, 'stream is not readable', {\n      type: 'stream.not.readable'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n\n/**\n * Try to require async_hooks\n * @private\n */\n\nfunction tryRequireAsyncHooks () {\n  try {\n    return require('async_hooks')\n  } catch (e) {\n    return {}\n  }\n}\n\n/**\n * Wrap function with async resource, if possible.\n * AsyncResource.bind static method backported.\n * @private\n */\n\nfunction wrap (fn) {\n  var res\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}