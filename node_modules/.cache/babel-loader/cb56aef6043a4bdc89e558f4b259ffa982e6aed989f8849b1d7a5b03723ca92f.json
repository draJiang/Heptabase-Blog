{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('unist-util-is').AssertPredicate<Element>} AssertElement\n * @typedef {import('unist-util-is').AssertPredicate<Text>} AssertText\n * @typedef {import('unist-util-is').AssertPredicate<Root>} AssertRoot\n *\n * @callback CreateElementLike\n * @param {string} name\n * @param {any} attributes\n * @param {Array.<string|any>} [children]\n * @returns {any}\n *\n * @typedef Context\n * @property {html|svg} schema\n * @property {string|null} prefix\n * @property {number} key\n * @property {boolean} react\n * @property {boolean} vue\n * @property {boolean} vdom\n * @property {boolean} hyperscript\n *\n * @typedef Options\n * @property {string|null} [prefix]\n * @property {'html'|'svg'} [space]\n */\n\nimport { html, svg, find, hastToReact } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { stringify as commas } from 'comma-separated-tokens';\nimport style from 'style-to-object';\nimport { webNamespaces } from 'web-namespaces';\nimport { convert } from 'unist-util-is';\nconst ns = /** @type {Record<string, string>} */webNamespaces;\nconst toReact = /** @type {Record<string, string>} */hastToReact;\nconst own = {}.hasOwnProperty;\n\n/** @type {AssertRoot} */\n// @ts-expect-error it’s correct.\nconst root = convert('root');\n/** @type {AssertElement} */\n// @ts-expect-error it’s correct.\nconst element = convert('element');\n/** @type {AssertText} */\n// @ts-expect-error it’s correct.\nconst text = convert('text');\n\n/**\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element|Root} tree\n * @param {string|boolean|Options} [options]\n * @returns {ReturnType<H>}\n */\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function');\n  }\n  const r = react(h);\n  const v = vue(h);\n  const vd = vdom(h);\n  /** @type {string|boolean|null|undefined} */\n  let prefix;\n  /** @type {Element} */\n  let node;\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options;\n    options = {};\n  } else {\n    if (!options) options = {};\n    prefix = options.prefix;\n  }\n  if (root(tree)) {\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node = tree.children.length === 1 && element(tree.children[0]) ? tree.children[0] : {\n      type: 'element',\n      tagName: 'div',\n      properties: {},\n      children: tree.children\n    };\n  } else if (element(tree)) {\n    node = tree;\n  } else {\n    throw new Error(\n    // @ts-expect-error runtime.\n    'Expected root or element, not `' + (tree && tree.type || tree) + '`');\n  }\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix: prefix === undefined || prefix === null ? r || v || vd ? 'h-' : null : typeof prefix === 'string' ? prefix : prefix ? 'h-' : null,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  });\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element} node\n * @param {Context} ctx\n */\nfunction transform(h, node, ctx) {\n  const parentSchema = ctx.schema;\n  let schema = parentSchema;\n  let name = node.tagName;\n  /** @type {Record<string, unknown>} */\n  const attributes = {};\n  /** @type {Array.<ReturnType<H>|string>} */\n  const nodes = [];\n  let index = -1;\n  /** @type {string} */\n  let key;\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg;\n    ctx.schema = schema;\n  }\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], ctx, name);\n    }\n  }\n  if (ctx.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase();\n    } else if (schema.space) {\n      attributes.namespace = ns[schema.space];\n    }\n  }\n  if (ctx.prefix) {\n    ctx.key++;\n    attributes.key = ctx.prefix + ctx.key;\n  }\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index];\n      if (element(value)) {\n        nodes.push(transform(h, value, ctx));\n      } else if (text(value)) {\n        nodes.push(value.value);\n      }\n    }\n  }\n\n  // Restore parent schema.\n  ctx.schema = parentSchema;\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0 ? h.call(node, name, attributes, nodes) : h.call(node, name, attributes);\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n * @param {string} name\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, ctx, name) {\n  const info = find(ctx.schema, prop);\n  /** @type {string|undefined} */\n  let subprop;\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (value === undefined || value === null || typeof value === 'number' && Number.isNaN(value) || value === false && (ctx.vue || ctx.vdom || ctx.hyperscript) || !value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript)) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && ctx.hyperscript) {\n    value = '';\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (info.property === 'style' && typeof value === 'string' && (ctx.react || ctx.vue || ctx.vdom)) {\n    value = parseStyle(value, name);\n  }\n  if (ctx.vue) {\n    if (info.property !== 'style') subprop = 'attrs';\n  } else if (!info.mustUseProperty) {\n    if (ctx.vdom) {\n      if (info.property !== 'style') subprop = 'attributes';\n    } else if (ctx.hyperscript) {\n      subprop = 'attrs';\n    }\n  }\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    });\n  } else if (info.space && ctx.react) {\n    props[toReact[info.property] || info.property] = value;\n  } else {\n    props[info.attribute] = value;\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction react(h) {\n  /** @type {unknown} */\n  const node = h('div', {});\n  return Boolean(node && (\n  // @ts-expect-error Looks like a React node.\n  '_owner' in node || '_store' in node) && (\n  // @ts-expect-error Looks like a React node.\n  node.key === undefined || node.key === null));\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h;\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vdom(h) {\n  /** @type {unknown} */\n  const node = h('div', {});\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode';\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vue(h) {\n  /** @type {unknown} */\n  const node = h('div', {});\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue);\n}\n\n/**\n * @param {string} value\n * @param {string} tagName\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {};\n  try {\n    style(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4);\n      result[name.replace(/-([a-z])/g,\n      /**\n       * @param {string} _\n       * @param {string} $1\n       * @returns {string}\n       */\n      (_, $1) => $1.toUpperCase())] = value;\n    });\n  } catch (error) {\n    error.message = tagName + '[style]' + error.message.slice('undefined'.length);\n    throw error;\n  }\n  return result;\n}","map":{"version":3,"names":["html","svg","find","hastToReact","stringify","spaces","commas","style","webNamespaces","convert","ns","toReact","own","hasOwnProperty","root","element","text","toH","h","tree","options","TypeError","r","react","v","vue","vd","vdom","prefix","node","children","length","type","tagName","properties","Error","transform","schema","space","undefined","key","hyperscript","ctx","parentSchema","name","attributes","nodes","index","toLowerCase","call","addAttribute","toUpperCase","namespace","value","push","props","prop","info","subprop","Number","isNaN","boolean","Array","isArray","commaSeparated","property","parseStyle","mustUseProperty","Object","assign","attribute","Boolean","context","_isVue","result","slice","replace","_","$1","error","message"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/hast-to-hyperscript/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('unist-util-is').AssertPredicate<Element>} AssertElement\n * @typedef {import('unist-util-is').AssertPredicate<Text>} AssertText\n * @typedef {import('unist-util-is').AssertPredicate<Root>} AssertRoot\n *\n * @callback CreateElementLike\n * @param {string} name\n * @param {any} attributes\n * @param {Array.<string|any>} [children]\n * @returns {any}\n *\n * @typedef Context\n * @property {html|svg} schema\n * @property {string|null} prefix\n * @property {number} key\n * @property {boolean} react\n * @property {boolean} vue\n * @property {boolean} vdom\n * @property {boolean} hyperscript\n *\n * @typedef Options\n * @property {string|null} [prefix]\n * @property {'html'|'svg'} [space]\n */\n\nimport {html, svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport style from 'style-to-object'\nimport {webNamespaces} from 'web-namespaces'\nimport {convert} from 'unist-util-is'\n\nconst ns = /** @type {Record<string, string>} */ (webNamespaces)\nconst toReact = /** @type {Record<string, string>} */ (hastToReact)\n\nconst own = {}.hasOwnProperty\n\n/** @type {AssertRoot} */\n// @ts-expect-error it’s correct.\nconst root = convert('root')\n/** @type {AssertElement} */\n// @ts-expect-error it’s correct.\nconst element = convert('element')\n/** @type {AssertText} */\n// @ts-expect-error it’s correct.\nconst text = convert('text')\n\n/**\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element|Root} tree\n * @param {string|boolean|Options} [options]\n * @returns {ReturnType<H>}\n */\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function')\n  }\n\n  const r = react(h)\n  const v = vue(h)\n  const vd = vdom(h)\n  /** @type {string|boolean|null|undefined} */\n  let prefix\n  /** @type {Element} */\n  let node\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options\n    options = {}\n  } else {\n    if (!options) options = {}\n    prefix = options.prefix\n  }\n\n  if (root(tree)) {\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node =\n      tree.children.length === 1 && element(tree.children[0])\n        ? tree.children[0]\n        : {\n            type: 'element',\n            tagName: 'div',\n            properties: {},\n            children: tree.children\n          }\n  } else if (element(tree)) {\n    node = tree\n  } else {\n    throw new Error(\n      // @ts-expect-error runtime.\n      'Expected root or element, not `' + ((tree && tree.type) || tree) + '`'\n    )\n  }\n\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix:\n      prefix === undefined || prefix === null\n        ? r || v || vd\n          ? 'h-'\n          : null\n        : typeof prefix === 'string'\n        ? prefix\n        : prefix\n        ? 'h-'\n        : null,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  })\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element} node\n * @param {Context} ctx\n */\nfunction transform(h, node, ctx) {\n  const parentSchema = ctx.schema\n  let schema = parentSchema\n  let name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const attributes = {}\n  /** @type {Array.<ReturnType<H>|string>} */\n  const nodes = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg\n    ctx.schema = schema\n  }\n\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], ctx, name)\n    }\n  }\n\n  if (ctx.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase()\n    } else if (schema.space) {\n      attributes.namespace = ns[schema.space]\n    }\n  }\n\n  if (ctx.prefix) {\n    ctx.key++\n    attributes.key = ctx.prefix + ctx.key\n  }\n\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index]\n\n      if (element(value)) {\n        nodes.push(transform(h, value, ctx))\n      } else if (text(value)) {\n        nodes.push(value.value)\n      }\n    }\n  }\n\n  // Restore parent schema.\n  ctx.schema = parentSchema\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0\n    ? h.call(node, name, attributes, nodes)\n    : h.call(node, name, attributes)\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n * @param {string} name\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, ctx, name) {\n  const info = find(ctx.schema, prop)\n  /** @type {string|undefined} */\n  let subprop\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (\n    value === undefined ||\n    value === null ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (value === false && (ctx.vue || ctx.vdom || ctx.hyperscript)) ||\n    (!value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && ctx.hyperscript) {\n    value = ''\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (\n    info.property === 'style' &&\n    typeof value === 'string' &&\n    (ctx.react || ctx.vue || ctx.vdom)\n  ) {\n    value = parseStyle(value, name)\n  }\n\n  if (ctx.vue) {\n    if (info.property !== 'style') subprop = 'attrs'\n  } else if (!info.mustUseProperty) {\n    if (ctx.vdom) {\n      if (info.property !== 'style') subprop = 'attributes'\n    } else if (ctx.hyperscript) {\n      subprop = 'attrs'\n    }\n  }\n\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    })\n  } else if (info.space && ctx.react) {\n    props[toReact[info.property] || info.property] = value\n  } else {\n    props[info.attribute] = value\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction react(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  return Boolean(\n    node &&\n      // @ts-expect-error Looks like a React node.\n      ('_owner' in node || '_store' in node) &&\n      // @ts-expect-error Looks like a React node.\n      (node.key === undefined || node.key === null)\n  )\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vdom(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode'\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vue(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue)\n}\n\n/**\n * @param {string} value\n * @param {string} tagName\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    style(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4)\n\n      result[\n        name.replace(\n          /-([a-z])/g,\n          /**\n           * @param {string} _\n           * @param {string} $1\n           * @returns {string}\n           */ (_, $1) => $1.toUpperCase()\n        )\n      ] = value\n    })\n  } catch (error) {\n    error.message =\n      tagName + '[style]' + error.message.slice('undefined'.length)\n    throw error\n  }\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}