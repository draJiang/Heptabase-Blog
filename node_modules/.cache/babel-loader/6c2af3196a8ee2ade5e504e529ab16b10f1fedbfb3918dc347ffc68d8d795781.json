{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g;\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n/**\n * @type {(\n *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n * )}\n */\n\n/**\n * @param {string} [selector]\n * @param {string} [defaultTagName='div']\n * @returns {Element}\n */\nfunction (selector) {\n  let defaultTagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';\n  var value = selector || '';\n  /** @type {Properties} */\n  var props = {};\n  var start = 0;\n  /** @type {string} */\n  var subvalue;\n  /** @type {string} */\n  var previous;\n  /** @type {RegExpMatchArray} */\n  var match;\n  while (start < value.length) {\n    search.lastIndex = start;\n    match = search.exec(value);\n    subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        defaultTagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: 'element',\n    tagName: defaultTagName,\n    properties: props,\n    children: []\n  };\n};","map":{"version":3,"names":["search","parseSelector","selector","defaultTagName","value","props","start","subvalue","previous","match","length","lastIndex","exec","slice","index","id","Array","isArray","className","push","type","tagName","properties","children"],"sources":["/Users/jiangzilong/学习/minpg/Heptabase-Blog/node_modules/hast-util-parse-selector/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n  /**\n   * @type {(\n   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n   * )}\n   */\n  (\n    /**\n     * @param {string} [selector]\n     * @param {string} [defaultTagName='div']\n     * @returns {Element}\n     */\n    function (selector, defaultTagName = 'div') {\n      var value = selector || ''\n      /** @type {Properties} */\n      var props = {}\n      var start = 0\n      /** @type {string} */\n      var subvalue\n      /** @type {string} */\n      var previous\n      /** @type {RegExpMatchArray} */\n      var match\n\n      while (start < value.length) {\n        search.lastIndex = start\n        match = search.exec(value)\n        subvalue = value.slice(start, match ? match.index : value.length)\n\n        if (subvalue) {\n          if (!previous) {\n            defaultTagName = subvalue\n          } else if (previous === '#') {\n            props.id = subvalue\n          } else if (Array.isArray(props.className)) {\n            props.className.push(subvalue)\n          } else {\n            props.className = [subvalue]\n          }\n\n          start += subvalue.length\n        }\n\n        if (match) {\n          previous = match[0]\n          start++\n        }\n      }\n\n      return {\n        type: 'element',\n        tagName: defaultTagName,\n        properties: props,\n        children: []\n      }\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAG,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa;AACxB;AACF;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,UAAUC,QAAQ,EAA0B;EAAA,IAAxBC,cAAc,uEAAG,KAAK;EACxC,IAAIC,KAAK,GAAGF,QAAQ,IAAI,EAAE;EAC1B;EACA,IAAIG,KAAK,GAAG,CAAC,CAAC;EACd,IAAIC,KAAK,GAAG,CAAC;EACb;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,KAAK;EAET,OAAOH,KAAK,GAAGF,KAAK,CAACM,MAAM,EAAE;IAC3BV,MAAM,CAACW,SAAS,GAAGL,KAAK;IACxBG,KAAK,GAAGT,MAAM,CAACY,IAAI,CAACR,KAAK,CAAC;IAC1BG,QAAQ,GAAGH,KAAK,CAACS,KAAK,CAACP,KAAK,EAAEG,KAAK,GAAGA,KAAK,CAACK,KAAK,GAAGV,KAAK,CAACM,MAAM,CAAC;IAEjE,IAAIH,QAAQ,EAAE;MACZ,IAAI,CAACC,QAAQ,EAAE;QACbL,cAAc,GAAGI,QAAQ;MAC3B,CAAC,MAAM,IAAIC,QAAQ,KAAK,GAAG,EAAE;QAC3BH,KAAK,CAACU,EAAE,GAAGR,QAAQ;MACrB,CAAC,MAAM,IAAIS,KAAK,CAACC,OAAO,CAACZ,KAAK,CAACa,SAAS,CAAC,EAAE;QACzCb,KAAK,CAACa,SAAS,CAACC,IAAI,CAACZ,QAAQ,CAAC;MAChC,CAAC,MAAM;QACLF,KAAK,CAACa,SAAS,GAAG,CAACX,QAAQ,CAAC;MAC9B;MAEAD,KAAK,IAAIC,QAAQ,CAACG,MAAM;IAC1B;IAEA,IAAID,KAAK,EAAE;MACTD,QAAQ,GAAGC,KAAK,CAAC,CAAC,CAAC;MACnBH,KAAK,EAAE;IACT;EACF;EAEA,OAAO;IACLc,IAAI,EAAE,SAAS;IACfC,OAAO,EAAElB,cAAc;IACvBmB,UAAU,EAAEjB,KAAK;IACjBkB,QAAQ,EAAE;EACZ,CAAC;AACH,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}